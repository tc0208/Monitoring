#!/usr/bin/perl -w
# $Id$
# $URL$

use strict;
use POSIX qw(mktime strftime);
use Getopt::Long;

my $cgi_called = $ENV{GATEWAY_INTERFACE};
my $cgi_query = $ENV{QUERY_STRING};
my $root = "/home/fih";
#my $root = $ENV{ROOT};
%ENV = ();

$ENV{PATH} = "/bin:/usr/bin";

if ($root) {
    # Support a minimal subset of valid filename characters.
    if ($root =~ /^(\/[-_\/A-Za-z0-9]+)$/) {
       $ENV{ROOT} = $root = $1;
    } else {
       die "Invalid setting for ROOT environment var";
    }
} else {
    $root = "/home/fih";
}

my $GATHER = "$root/sbin/ysar_gather";
my $DATFILE = "$root/logs/ysar/ysar.dat";
my @pc = glob("/home/fih/conf/ysar/plugins/*.conf");
my @plugins;
my %plugins = (opts => 0,
               cgi => 0,
               getopts => 0,
               not_opt => '!$opt_kmem',
               metrics => 0,
               dat => 0,
               stats => 0,
               columns => 0,
               show_stats => 0,
               header1 => 0,
               header2 => 0,
               usage => 0);

if (scalar(@pc)) {
   my @settings = qw(NAME METRICS HEADER1 HEADER2 USAGE GATHER);
   foreach my $p (@pc) {
      my %conf; $conf{'NCOL'} = 0;
      open(PLUGIN, '<', $p) or die "Can't read plugin configuration $p: $!\n";
      while (<PLUGIN>) {
         if ($_ =~ /^([A-Z]+[12]?)=(.*)$/) {
            my ($k,$v) = ($1,$2);
            if (grep $_ eq $k, @settings) { $conf{$k} = $v; }
            elsif ($k eq 'COLUMN') { $conf{'COLUMN'.$conf{'NCOL'}} = $v; $conf{'NCOL'} += 1; }
            else { die "Unknown plugin directive: $k\n"; }
         }
         elsif ($_ !~ /^[\s]*(#(.*))*$/) {
            die "Garbled configuration line in $p: $_\n";
         }
      }
      close(PLUGIN);
      push(@plugins,\%conf);
   }
   foreach my $key (keys %plugins) { $plugins{$key} = plugin_conf($key); }
}

my $opt_cpushare = 0;
my $opt_mem = 0;
my $opt_memx = 0;
my $opt_load = 0;
my $opt_ps = 0;
my $opt_sys = 0;
my $opt_swap = 0;
my $opt_fork = 0;
my $opt_tcp = 0;
my $opt_udp = 0;
my $opt_ip = 0;
my $opt_devstat = 0;
my $opt_if = 0;
my $opt_df = 0;
my $opt_mysql = 0;
my $opt_ysquid = 0;
my $opt_ysquidhealth = 0;
my $opt_innodb = 0;
my $interval;
my $ndays = 0;
my $opt_day = 0;
my $opt_summary = 0;
my $opt_apache = 0;
my $opt_yts = 0;
my $opt_ytsall = 0;
my $opt_ytscache = 0;
my $opt_ytserr = 0;
my $opt_ytstls = 0;
my $opt_raw = 0;
my $opt_accumulate = 0;
my $opt_help = 0;
my $opt_plot;
my $opt_plottype;
my $plotcolors = '';
my $cgi;
my $hdrint;
my $opt_current = 0;
my $opt_nfsrops = 0;
my $opt_nfswops = 0;
my $opt_nfscache = 0;
my $opt_util = 0;
my $opt_ciss = 0;
my $opt_tcpx = 0;
my $opt_kmem = 0;
my $opt_Max = 0;
my $opt_version;
my $opt_shmproxy_que = 0;
my $opt_shmproxy_drops = 0;
my $opt_shmproxy_ci = 0;
my $opt_shmproxy_co = 0;
my $opt_shmproxy_pi = 0;
my $opt_shmproxy_po = 0;
my $opt_shmproxy_rd = 0;
my $opt_ynodejs = 0;
my $opt_nfsopx = 0;
my $opt_nfsop_mount = '';
my $opt_nfsop_op = '';
my $opt_apache_name = '';
eval $plugins{'opts'};

if ($cgi_called) {
    require CGI;
    $cgi = new CGI($cgi_query);
    $opt_cpushare = $cgi->param("cpu");
    $opt_mem = $cgi->param("mem");
    $opt_memx = $cgi->param("memx");
    $opt_load = $cgi->param("load");
    $opt_ps = $cgi->param("ps");
    $opt_sys = $cgi->param("sys");
    $opt_swap = $cgi->param("swap");
    $opt_fork = $cgi->param("fork");
    $opt_tcp = $cgi->param("tcp");
    $opt_udp = $cgi->param("udp");
    $opt_ip = $cgi->param("ip");
    $opt_devstat = $cgi->param("dev");
    $opt_if = $cgi->param("if");
    $opt_df = $cgi->param("df");
    $opt_mysql = $cgi->param("mysql");
    $opt_ysquid = $cgi->param("ysquid");
    $opt_ysquidhealth = $cgi->param("ysquidhealth");
    $opt_innodb = $cgi->param("innodb");
    $interval = $cgi->param("interval");
    $ndays = $cgi->param("ndays");
    $opt_day = $cgi->param("day");
    $opt_summary = $cgi->param("Summary");
    $opt_apache = $cgi->param("apache");
    $opt_yts = $cgi->param("yts");
    $opt_yts = $cgi->param("ytsall");
    $opt_ytscache = $cgi->param("ytscache");
    $opt_ytserr = $cgi->param("ytserr");
    $opt_ytstls = $cgi->param("ytstls");
    $opt_raw = $cgi->param("raw");
    $opt_accumulate = $cgi->param("accum");
    $hdrint = $cgi->param("header");
    $opt_nfsrops = $cgi->param("nfsrops");
    $opt_nfswops = $cgi->param("nfswops");
    $opt_nfscache = $cgi->param("nfscache");
    $opt_util = $cgi->param("util");
    $opt_plot = $cgi->param("plot");
    $opt_plottype = $cgi->param("plottype");
    $plotcolors = $cgi->param("plotcolors");
    $opt_ciss = $cgi->param("ciss");
    $opt_tcpx = $cgi->param("tcpx");
    $opt_kmem = $cgi->param("kmem");
    $opt_Max = $cgi->param("Max");
    $opt_version = $cgi->param("version");
    $opt_shmproxy_que = $cgi->param("shmp");
    $opt_shmproxy_drops = $cgi->param("shmpd");
    $opt_shmproxy_ci = $cgi->param("shmpci");
    $opt_shmproxy_co = $cgi->param("shmpco");
    $opt_shmproxy_pi = $cgi->param("shmppi");
    $opt_shmproxy_po = $cgi->param("shmppo");
    $opt_shmproxy_rd = $cgi->param("shmprd");
    $opt_ynodejs = $cgi->param("ynodejs");
    $opt_nfsopx = $cgi->param("nfsopx");
    $opt_nfsop_mount = $cgi->param("nfs-mount");
    $opt_nfsop_op = $cgi->param("nfs-op");
    $opt_apache_name = $cgi->param("apache-name");
    eval $plugins{'cgi'};

} else {
    if (!GetOptions("cpu" => \$opt_cpushare,
		    "mem" => \$opt_mem,
		    "memx" => \$opt_memx,
		    "load" => \$opt_load,
		    "ps" => \$opt_ps,
		    "sys" => \$opt_sys,
		    "swap" => \$opt_swap,
		    "fork" => \$opt_fork,
		    "tcp" => \$opt_tcp,
		    "udp" => \$opt_udp,
		    "ip" => \$opt_ip,
		    "dev" => \$opt_devstat,
		    "if" => \$opt_if,
		    "df" => \$opt_df,
		    "mysql" => \$opt_mysql,
		    "ysquid" => \$opt_ysquid,
		    "ysquidhealth" => \$opt_ysquidhealth,
		    "innodb" => \$opt_innodb,
		    "interval=i" => \$interval,
		    "ndays=i" => \$ndays,
		    "day" => \$opt_day,
		    "Summary" => \$opt_summary,
		    "apache" => \$opt_apache,
		    "yts" => \$opt_yts,
		    "ytsall" => \$opt_ytsall,
		    "ytscache" => \$opt_ytscache,
		    "ytserr" => \$opt_ytserr,
		    "ytstls" => \$opt_ytstls,
		    "raw" => \$opt_raw,
		    "accumulate" => \$opt_accumulate,
		    "help|h" => \$opt_help,
		    "header=i" => \$hdrint,
		    "current" => \$opt_current,
		    "nfsrops" => \$opt_nfsrops,
		    "nfswops" => \$opt_nfswops,
		    "nfscache" => \$opt_nfscache,
		    "util" => \$opt_util,
		    "ciss" => \$opt_ciss,
		    "tcpx" => \$opt_tcpx,
		    "kmem" => \$opt_kmem,
		    "log=s" => \$DATFILE,
		    "Max" => \$opt_Max,
		    "version" => \$opt_version,
		    "shmp" => \$opt_shmproxy_que,
		    "shmpd" => \$opt_shmproxy_drops,
		    "shmpci" => \$opt_shmproxy_ci,
		    "shmpco" => \$opt_shmproxy_co,
		    "shmppi" => \$opt_shmproxy_pi,
		    "shmppo" => \$opt_shmproxy_po,
		    "shmprd" => \$opt_shmproxy_rd,
		    "ynodejs" => \$opt_ynodejs,
		    "nfsopx" => \$opt_nfsopx,
		    "nfs-mount=s" => \$opt_nfsop_mount,
		    "nfs-op=s" => \$opt_nfsop_op,
		    "apache-name=s" => \$opt_apache_name,
		    eval $plugins{'getopts'})
       )
    {
	usage();
	exit(1);
    }
}
if (!defined($hdrint)) {
    if ($opt_current) {
	$hdrint = -1;
    } else {
	$hdrint = 40;
    }
}

if ($opt_help) {
    usage();
}

if ($opt_nfsopx && (($opt_nfsop_mount eq '') || ($opt_nfsop_op eq '') || !valid_nfs_op())) {
    usage();
}

my $DAY_SECS = 24*60*60;

if (!defined($interval) || !$interval) {
    if ($opt_current) {
	$interval = $DAY_SECS;
    } else {
	$interval = 30;
    }
}
if ($ndays) {
    if ($ndays =~ /^([0-9]+)$/) {
	$ndays = $1;
    } else {
	die("Bad ndays value");
    }
} else {
    $ndays = 1;
}

if ($opt_version) {
    version();
    exit(0);
}

if ($opt_plot) {
    if (!defined($plotcolors)) {
        $plotcolors = '';
    }
    plot();
    exit(0);
}

if  (!$opt_cpushare && !$opt_load && !$opt_mem && !$opt_ps && !$opt_sys && !$opt_swap
    && !$opt_fork && !$opt_tcp && !$opt_udp && !$opt_ip && !$opt_devstat
    && !$opt_if && !$opt_df && !$opt_apache && !$opt_yts && !$opt_ytsall
    && !$opt_innodb && !$opt_ysquid && !$opt_ysquidhealth && !$opt_memx
    && !$opt_ytserr && !$opt_ytscache && !$opt_ytstls && !$opt_mysql && !$opt_nfsrops
    && !$opt_nfswops && !$opt_nfscache && !$opt_util && !$opt_ciss
    && !$opt_tcpx && !$opt_kmem && !$opt_shmproxy_que && !$opt_shmproxy_drops 
    && !$opt_shmproxy_ci && !$opt_shmproxy_co && !$opt_shmproxy_pi
    && !$opt_shmproxy_po && !$opt_shmproxy_rd && !$opt_ynodejs 
    && !$opt_nfsopx &&  eval $plugins{'not_opt'})
{
    $opt_summary = 1;
}

if ($opt_ytsall) {
  $opt_yts = 1;
  $opt_ytscache = 1;
  $opt_ytserr = 1;
  $opt_ytstls = 1;
}

my $os = "rhel";
#my $os = `/usr/local/bin/yinst-platform os`;
chomp($os);

my $now = time();

my($reboot_t,$reboot_usec);
if ($os eq "freebsd") {
    my $s = `/sbin/sysctl -b kern.boottime`;
    ($reboot_t,$reboot_usec) = unpack("LL",$s);
}
if ($os eq "rhel") {
    if (open(F,"/proc/uptime")) {
	while (<F>) {
	    if (/^([\d.]+)\s+([\d.]+)/) {
		my $reboot = $now - $1;
		$reboot_t = int($reboot);
		$reboot_usec = ($reboot - $reboot_t) * 1000000;
		last;
	    }
	}
	close(F);
    }
}

my $start;
my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($now);
if ($opt_day) {
    $start = mktime(0,0,0,$mday,$mon,$year,$wday,$yday,$isdst)
	- ($ndays-1)*$DAY_SECS;
    $interval = $DAY_SECS;
} else {
    $start = mktime(0,0,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
	- $ndays*$DAY_SECS;
    $interval *= 60;
}
my $end = $now;

my $t_prev = 0;

my($CP_USER,$CP_NICE,$CP_SYS,$CP_INTR,$CP_IDLE,$CP_IOWAIT) = (0..5);
my(@CPUT_prev,@CPUT_sum);

my($MEM_TOTAL,$MEM_ACTIVE,$MEM_FREE,$MEM_WIRED,$MEM_INACTIVE,$MEM_CACHED) = (0..5);
my(@MEM_sum);

my($MEMX_BUFFERS,$MEMX_CACHED,$MEMX_SWAP_TOTAL,$MEMX_SWAP_FREE,$MEMX_HP_TOTAL,$MEMX_HP_FREE,$MEMX_HP_RSVD,$MEMX_HP_SURP,$MEMX_HP_SIZE) = (0..8);
my(@MEMX_sum);

my($LD_1M,$LD_5M,$LD_15M) = (0..2);
my(@LD_sum);

my($PS_RUN,$PS_SLEEP,$PS_IDLE,$PS_DISK) = (0..3);
my(@PS_sum);

my($SYS_SWTCH,$SYS_TRAP,$SYS_SYSCALL,$SYS_INTR,$SYS_SOFT) = (2,3,0,1,4);
my(@SYS_sum,@SYS_prev);

my($SWAP_PGSOUT,$SWAP_VNODEPGSOUT,$SWAP_PGSIN,$SWAP_VNODEPGSIN) = (0..3);
my(@SWAP_sum,@SWAP_prev);

my($FORK_FORKS,$FORK_VFORKS) = (0,1);
my(@FORK_sum,@FORK_prev);

my($IP_RECVPKT,$IP_SENDPKT,$IP_UDPRECVPKT,$IP_UDPSENDPKT,
   $IP_TCPRECVPKT,$IP_TCPSENDPKT,$IP_TCPRECVBYTE,$IP_TCPSENDBYTE,
   $IP_TCPREXMITPKT,$IP_TCPREXMITBYTE,$IP_UDPDROPPED,
   $IP_TCPSYNCADD,$IP_TCPSYNCBO,$IP_TCPSYNCCO)
    = (0..13);
my(@IP_sum,@IP_prev);

my($DS_READS_H,$DS_READS_L,$DS_RBYTES_H,$DS_RBYTES_L,$DS_WRITES_H,$DS_WRITES_L,
   $DS_WBYTES_H,$DS_WBYTES_L,$DS_BUSY_SEC,$DS_BUSY_USEC) = (0..9);
my($DS_READS,$DS_RBYTES,$DS_WRITES,$DS_WBYTES,$DS_BUSY,$DS_QUEUE,$DS_NIOS,$DS_NTICKS,$DS_BIOTICKS) = (0..8);
my(%DS_sum,%DS_prev);

my($IF_RECVPKT,$IF_RECVBYTE,$IF_SENDPKT,$IF_SENDBYTE,$IF_IERRS,$IF_OERRS,$IF_COLL) = (0..6);
my(%IF_sum,%IF_prev);

my($YAP_REQUESTS,$YAP_RT,$YAP_BYTES_IN,$YAP_BYTES_OUT,$YAP_ACTIVE_CHILDREN,
   $YAP_IDLE_CHILDREN,$YAP_CHILD_STARTS,$YAP_MAX_ACTIVE_CHILDREN) = (0..7);
my(@YAP_sum,@YAP_prev,@YAP_max);

my($YTS_CLIENT_CONNS,$YTS_CUR_CLIENT_CONNS,
   $YTS_SERVER_CONNS,$YTS_CUR_SERVER_CONNS,
   $YTS_INCOMING_REQS,$YTS_OUTGOING_REQS,
   $YTS_CLIENT_BYTES,$YTS_ORIGIN_BYTES,
   $YTS_TRANS_TIMES_MS,
   $YTS_CACHE_HITS,$YTS_CACHE_MISSES,
   $YTS_RAM_CACHE_HITS,$YTS_RAM_CACHE_MISSES,$YTS_ACTIVE_IN_CACHE,
   $YTS_CACHE_READ_ERR, $YTS_CACHE_WRITE_ERR,
   $YTS_MISSING_HOST,$YTS_ABORTS,$YTS_HANGUPS,$YTS_CONNECT_FAIL,$YTS_ERR_OTHER,
   $YTS_CACHE_HITS_T, $YTS_CACHE_MISSES_T,
   $YTS_UA_TLS_OTHER,$YTS_UA_TLS_EXPIRED,$YTS_UA_TLS_REVOKED,$YTS_UA_TLS_UNKNOWN,
   $YTS_UA_TLS_VERIFY,$YTS_UA_TLS_BADCERT,$YTS_UA_TLS_DECRYPT,$YTS_UA_TLS_VERSION,
   $YTS_UA_TLS_UNKNOWNCA)
   = (0..31);
my (@YTS_sum,@YTS1_sum,@YTS_prev, @YTS_max);

my($DF_TOTAL,$DF_USED,$DF_ITOTAL,$DF_IUSED) = (0..3);
my(%DF_sum,%DF_prev);

my($MYSQL_ABORTED_CLIENTS,$MYSQL_ABORTED_CONNECTS,$MYSQL_BYTES_RECEIVED,$MYSQL_BYTES_SENT,
   $MYSQL_DELETES,$MYSQL_INSERTS,$MYSQL_SELECTS,$MYSQL_UPDATES,$MYSQL_CONNECTIONS,
   $MYSQL_HANDLER_DELETE,$MYSQL_HANDLER_READ_FIRST,$MYSQL_HANDLER_READ_KEY,
   $MYSQL_HANDLER_READ_RND,$MYSQL_HANDLER_READ_RND_NEXT,$MYSQL_HANDLER_UPDATE,
   $MYSQL_HANDLER_WRITE,$MYSQL_KEY_BLOCKS_USED,
   $MYSQL_KEY_READ_REQUESTS,$MYSQL_KEY_READS,$MYSQL_KEY_WRITE_REQUESTS,$MYSQL_KEY_WRITES,
   $MYSQL_MAX_USED_CONNECTIONS,$MYSQL_QUESTIONS,
   $MYSQL_QCACHE_LOWMEM_PRUNES,$MYSQL_QCACHE_QUERIES_IN_CACHE,
   $MYSQL_QCACHE_INSERTS,$MYSQL_QCACHE_HITS,$MYSQL_QCACHE_FREE_MEMORY,
   $MYSQL_QCACHE_NOT_CACHED,$MYSQL_SLOW_QUERIES,$MYSQL_SORT_MERGE_PASSES,
   $MYSQL_TABLE_LOCKS_IMMEDIATE,$MYSQL_TABLE_LOCKS_WAITED,
   $MYSQL_THREADS_CONNECTED,$MYSQL_THREADS_RUNNING,
   $MYSQL_KEY_BUFFER_SIZE,$MYSQL_QUERY_ALLOC_BLOCK_SIZE,$MYSQL_QUERY_CACHE_SIZE,
   $MYSQL_REPL_DELAY, $MYSQL_KEY_BLOCKS_UNUSED, $MYSQL_THREADS_CACHED, $MYSQL_THREADS_CREATED,
   $MYSQL_Innodb_buffer_pool_pages_data, $MYSQL_Innodb_buffer_pool_pages_dirty, $MYSQL_Innodb_buffer_pool_pages_flushed,
   $MYSQL_Innodb_buffer_pool_pages_free, $MYSQL_Innodb_buffer_pool_pages_latched, $MYSQL_Innodb_buffer_pool_pages_misc,
   $MYSQL_Innodb_buffer_pool_pages_total, $MYSQL_Innodb_buffer_pool_read_ahead_rnd, 
   $MYSQL_Innodb_buffer_pool_read_ahead_seq, $MYSQL_Innodb_buffer_pool_read_requests, $MYSQL_Innodb_buffer_pool_reads,
   $MYSQL_Innodb_buffer_pool_wait_free, $MYSQL_Innodb_buffer_pool_write_requests, $MYSQL_Innodb_data_fsyncs,
   $MYSQL_Innodb_data_pending_fsyncs, $MYSQL_Innodb_data_pending_reads, $MYSQL_Innodb_data_pending_writes,
   $MYSQL_Innodb_data_read, $MYSQL_Innodb_data_reads, $MYSQL_Innodb_data_writes, $MYSQL_Innodb_data_written,
   $MYSQL_Innodb_dblwr_pages_written, $MYSQL_Innodb_dblwr_writes, $MYSQL_Innodb_log_waits,
   $MYSQL_Innodb_log_write_requests, $MYSQL_Innodb_log_writes, $MYSQL_Innodb_os_log_fsyncs,
   $MYSQL_Innodb_os_log_pending_fsyncs, $MYSQL_Innodb_os_log_pending_writes, $MYSQL_Innodb_os_log_written,
   $MYSQL_Innodb_page_size, $MYSQL_Innodb_pages_created, $MYSQL_Innodb_pages_read, $MYSQL_Innodb_pages_written,
   $MYSQL_Innodb_row_lock_current_waits, $MYSQL_Innodb_row_lock_time, $MYSQL_Innodb_row_lock_time_avg,
   $MYSQL_Innodb_row_lock_time_max, $MYSQL_Innodb_row_lock_waits, $MYSQL_Innodb_rows_deleted, 
   $MYSQL_Innodb_rows_inserted, $MYSQL_Innodb_rows_read, $MYSQL_Innodb_rows_updated
   )
    = (0..84);

my(@MYSQL_sum,@MYSQL_prev,@MYSQL_ssum);

my($YSQUID_REQUESTS,
   $YSQUID_HITS,
   $YSQUID_MISSES,
   $YSQUID_TCP_HIT,
   $YSQUID_TCP_IMS_HIT,
   $YSQUID_TCP_REFRESH_HIT,
   $YSQUID_TCP_STALE_HIT,
   $YSQUID_TCP_MEM_HIT,
   $YSQUID_TCP_ASYNC_HIT,
   $YSQUID_TCP_ASYNC_MISS,
   $YSQUID_TCP_CLIENT_REFRESH_MISS,
   $YSQUID_TCP_MISS,
   $YSQUID_TCP_NEGATIVE_HIT,
   $YSQUID_TCP_REFRESH_MISS,
   $YSQUID_RT_HIT,
   $YSQUID_MEDIAN_RT_HIT,
   $YSQUID_RT_MISS,
   $YSQUID_MEDIAN_RT_MISS,
   $YSQUID_CLIENT_HTTP_KBIN,
   $YSQUID_CLIENT_HTTP_KBOUT,
   $YSQUID_CLIENT_HTTP_HIT_KBOUT,
   $YSQUID_ALL_KBIN,
   $YSQUID_ALL_KBOUT,
   $YSQUID_ICP_KBSENT,
   $YSQUID_ICP_KBRECV,
   $YSQUID_ICP_TIMEOUTS,
   $YSQUID_PAGE_FAULTS,
   $YSQUID_ABORTED_REQUESTS,
   $YSQUID_UPTIME,
   $YSQUID_MEMSIZE,
   $YSQUID_FD_USED,
   $YSQUID_STORE_FILES_OPEN,
   $YSQUID_STORE_DISK_SIZE,
   $YSQUID_STORE_MEM_SIZE,
   $YSQUID_MEAN_OBJ_SIZE
   )
    = (0..34);

my(@YSQUID_sum,@YSQUID_prev,@YSQUID_ssum);

my($NFS_ATTRCACHE_HITS,
   $NFS_ATTRCACHE_MISSES,
   $NFS_LOOKUPCACHE_HITS,
   $NFS_LOOKUPCACHE_MISSES,
   $NFS_DIREOFCACHE_HITS,
   $NFS_DIREOFCACHE_MISSES,
   $NFS_BIOCACHE_READS,
   $NFS_READ_BIOS,
   $NFS_READ_PHYSIOS,
   $NFS_BIOCACHE_WRITES,
   $NFS_WRITE_BIOS,
   $NFS_WRITE_PHYSIOS,
   $NFS_BIOCACHE_READLINKS,
   $NFS_READLINK_BIOS,
   $NFS_BIOCACHE_READDIRS,
   $NFS_READDIR_BIOS,
   $NFS_PROC_NULL,
   $NFS_PROC_GETATTR,
   $NFS_PROC_SETATTR,
   $NFS_PROC_LOOKUP,
   $NFS_PROC_ACCESS,
   $NFS_PROC_READLINK,
   $NFS_PROC_READ,
   $NFS_PROC_WRITE,
   $NFS_PROC_CREATE,
   $NFS_PROC_MKDIR,
   $NFS_PROC_SYMLINK,
   $NFS_PROC_MKNOD,
   $NFS_PROC_REMOVE,
   $NFS_PROC_RMDIR,
   $NFS_PROC_RENAME,
   $NFS_PROC_LINK,
   $NFS_PROC_READDIR,
   $NFS_PROC_READDIRPLUS,
   $NFS_PROC_FSSTAT,
   $NFS_PROC_FSINFO,
   $NFS_PROC_PATHCONF,
   $NFS_PROC_COMMIT,
   $NFS_PROC_GETLEASE,
   $NFS_PROC_VACATED,
   $NFS_PROC_EVICTED,
   $NFS_PROC_NOOP,
   $NFS_RPCRETRIES) = (0..41);
my(@NFS_prev,@NFS_sum);

my($NFS_LX_READ_OPS,
   $NFS_LX_READ_KB,
   $NFS_LX_READ_RETRANS,
   $NFS_LX_READ_RTT,
   $NFS_LX_READ_EXE,
   $NFS_LX_GATTR_OPS,
   $NFS_LX_GATTR_KB,
   $NFS_LX_GATTR_RETRANS,
   $NFS_LX_GATTR_RTT,
   $NFS_LX_GATTR_EXE,
   $NFS_LX_LOOKUP_OPS,
   $NFS_LX_LOOKUP_KB,
   $NFS_LX_LOOKUP_RETRANS,
   $NFS_LX_LOOKUP_RTT,
   $NFS_LX_LOOKUP_EXE,
   $NFS_LX_ACCESS_OPS,
   $NFS_LX_ACCESS_KB,
   $NFS_LX_ACCESS_RETRANS,
   $NFS_LX_ACCESS_RTT,
   $NFS_LX_ACCESS_EXE,
   $NFS_LX_RDLINK_OPS,
   $NFS_LX_RDLINK_KB,
   $NFS_LX_RDLINK_RETRANS,
   $NFS_LX_RDLINK_RTT,
   $NFS_LX_RDLINK_EXE,
   $NFS_LX_RDDIR_OPS,
   $NFS_LX_RDDIR_KB,
   $NFS_LX_RDDIR_RETRANS,
   $NFS_LX_RDDIR_RTT,
   $NFS_LX_RDDIR_EXE,
   $NFS_LX_RDDIRPLUS_OPS,
   $NFS_LX_RDDIRPLUS_KB,
   $NFS_LX_RDDIRPLUS_RETRANS,
   $NFS_LX_RDDIRPLUS_RTT,
   $NFS_LX_RDDIRPLUS_EXE,
   $NFS_LX_FSSTAT_OPS,
   $NFS_LX_FSSTAT_KB,
   $NFS_LX_FSSTAT_RETRANS,
   $NFS_LX_FSSTAT_RTT,
   $NFS_LX_FSSTAT_EXE,
   $NFS_LX_FSINFO_OPS,
   $NFS_LX_FSINFO_KB,
   $NFS_LX_FSINFO_RETRANS,
   $NFS_LX_FSINFO_RTT,
   $NFS_LX_FSINFO_EXE,
   $NFS_LX_PCONF_OPS,
   $NFS_LX_PCONF_KB,
   $NFS_LX_PCONF_RETRANS,
   $NFS_LX_PCONF_RTT,
   $NFS_LX_PCONF_EXE,
   $NFS_LX_WRITE_OPS,
   $NFS_LX_WRITE_KB,
   $NFS_LX_WRITE_RETRANS,
   $NFS_LX_WRITE_RTT,
   $NFS_LX_WRITE_EXE,
   $NFS_LX_SATTR_OPS,
   $NFS_LX_SATTR_KB,
   $NFS_LX_SATTR_RETRANS,
   $NFS_LX_SATTR_RTT,
   $NFS_LX_SATTR_EXE,
   $NFS_LX_CREATE_OPS,
   $NFS_LX_CREATE_KB,
   $NFS_LX_CREATE_RETRANS,
   $NFS_LX_CREATE_RTT,
   $NFS_LX_CREATE_EXE,
   $NFS_LX_MKDIR_OPS,
   $NFS_LX_MKDIR_KB,
   $NFS_LX_MKDIR_RETRANS,
   $NFS_LX_MKDIR_RTT,
   $NFS_LX_MKDIR_EXE,
   $NFS_LX_SYMLINK_OPS,
   $NFS_LX_SYMLINK_KB,
   $NFS_LX_SYMLINK_RETRANS,
   $NFS_LX_SYMLINK_RTT,
   $NFS_LX_SYMLINK_EXE,
   $NFS_LX_MKNODE_OPS,
   $NFS_LX_MKNODE_KB,
   $NFS_LX_MKNODE_RETRANS,
   $NFS_LX_MKNODE_RTT,
   $NFS_LX_MKNODE_EXE,
   $NFS_LX_REMOVE_OPS,
   $NFS_LX_REMOVE_KB,
   $NFS_LX_REMOVE_RETRANS,
   $NFS_LX_REMOVE_RTT,
   $NFS_LX_REMOVE_EXE,
   $NFS_LX_RMDIR_OPS,
   $NFS_LX_RMDIR_KB,
   $NFS_LX_RMDIR_RETRANS,
   $NFS_LX_RMDIR_RTT,
   $NFS_LX_RMDIR_EXE,
   $NFS_LX_RENAME_OPS,
   $NFS_LX_RENAME_KB,
   $NFS_LX_RENAME_RETRANS,
   $NFS_LX_RENAME_RTT,
   $NFS_LX_RENAME_EXE,
   $NFS_LX_LINK_OPS,
   $NFS_LX_LINK_KB,
   $NFS_LX_LINK_RETRANS,
   $NFS_LX_LINK_RTT,
   $NFS_LX_LINK_EXE) = (0..99);
my(%NFS_LX_sum,%NFS_LX_prev);

my($CISS_BUSY,$CISS_COMMANDS,$CISS_COMMAND_LATENCY,$CISS_ACTIVE,$CISS_LOGICAL_REQUESTS,
   $CISS_SAMPLE_INTERVAL)
    = (0,1,2,3,4,5);
my($CISS_LOGICAL_WRITES,$CISS_LOGICAL_READS,$CISS_QUEUE_DEPTH,$CISS_CACHE_HITS,$CISS_CACHE_MISSES,
   $CISS_READ_AHEAD_SECTORS,$CISS_SECTORS_READ,$CISS_SECTORS_WRITTEN,$CISS_NON_SEQ_READS,
   $CISS_NON_SEQ_WRITES,$CISS_READ_LATENCY,$CISS_WRITE_LATENCY,$CISS_UNALIGNED_READS,
   $CISS_UNALIGNED_WRITES,$CISS_NUM_ACTIVE_DRIVES,$CISS_NUM_SPARE_DRIVES,$CISS_READ_REQUESTS,
   $CISS_WRITE_REQUESTS) = (0..17);
my(@CISS_sum,@CISS_prev,@CISS1_sum,@CISS1_prev);
my(%CISS_sum,%CISS_prev,%CISSD_sum,%CISSD_prev);

my($KMEM_MBUF_USED,$KMEM_MBUF_MAX,$KMEM_MBUFC_USED,$KMEM_MBUFC_MAX,
   $KMEM_SOCK_USED,$KMEM_SOCK_MAX,$KMEM_PVENTRY_USED,$KMEM_PVENTRY_MAX,
   $KMEM_KVM,$KMEM_KVM_MAX,$KMEM_FILES,$KMEM_FILES_MAX) = (0..11);
my(@KMEM_sum,@KMEM_prev);

my($TCP_RECVQ,$TCP_SENDQ,
   $TCP_NCONNEST,$TCP_NCONNDROP,
   $TCP_EST,$TCP_TIME_WAIT,$TCP_FIN_WAIT_1,$TCP_FIN_WAIT_2,
   $TCP_LISTENQ,$TCP_LISTENINCQ,$TCP_LISTENOVER,
   $TCP_EMBDROP,$TCP_REXMITDROP,$TCP_PERSISTDROP,$TCP_KADROP)
    = (0..14);
my(@TCP_sum,@TCP1_sum,@TCP_prev);

my($SHMP_GID,
  $SHMP_MAX_CLIENTS,
  $SHMP_NUM_CLIENTS,
  $SHMP_MMAP_FD,
  $SHMP_MAX_SEGS,
  $SHMP_MAX_SEG_SIZE,
  $SHMP_MAX_XSEGS,
  $SHMP_MAX_XSEG_SIZE,
  $SHMP_XSEGS_USED_IN,
  $SHMP_XSEGS_USED_OUT,
  $SHMP_MIN_LOCKS,
  $SHMP_PORQSPACELIMIT,
  $SHMP_PORQMAX,
  $SHMP_MAXQUSE,
  $SHMP_NUMQUSED,
  $SHMP_SNDBUF,
  $SHMP_RECBUF,
  $SHMP_CONF_NUM_PROXIES,
  $SHMP_CONN_NUM_PROXIES,
  $SHMP_MAXQUEUELEN,
  $SHMP_MAXCLIENTQUEUES,
  $SHMP_NUMINQUEUES,
  $SHMP_BYTESINQUEUES,
  $SHMP_PGROUP_QUEUE_INQ,
  $SHMP_PGROUP_QUEUE_QLEN,
  $SHMP_BUCKET,
  $SHMP_IMIN,
  $SHMP_IMAX,
  $SHMP_ICOUNT,
  $SHMP_IMULTI,
  $SHMP_OMIN,
  $SHMP_OMAX,
  $SHMP_OCOUNT,
  $SHMP_OMULTI,
  $SHMP_I,
  $SHMP_O,
  $SHMP_Q,
  $SHMP_i,
  $SHMP_o,
  $SHMP_CINMSG,
  $SHMP_CINBYTE,
  $SHMP_COUTMSG,
  $SHMP_COUTBYTE,
  $SHMP_CCURQUEMSG,
  $SHMP_CCURQUEBYTE,
  $SHMP_CDROPMSG,
  $SHMP_CDROPBYTE,
  $SHMP_CTOTQUEMSG,
  $SHMP_CTOTQUEBYTE,
  $SHMP_PINMSG,
  $SHMP_PINBYTE,
  $SHMP_POUTMSG,
  $SHMP_POUTBYTE,
  $SHMP_PDROPMSG,
  $SHMP_PDROPBYTE,
  $SHMP_PTOTQUEMSG,
  $SHMP_PTOTQUEBYTE,
  $SHMP_PTOTQUEEXTENDED,
  $SHMP_START,
  $SHMP_UTIME,
  $SHMP_STIME,
  $SHMP_VSZ,
  $SHMP_RSS,
) = (0..64);

my(%SHMP_prev,%SHMP_sum,%SHMP_dvdt);

my($YNODEJS_REQUESTS,$YNODEJS_LATENCY,$YNODEJS_KBIN,$YNODEJS_KBOUT,$YNODEJS_AVGCONC,$YNODEJS_MAXCONC) = (0..5);
my(@YNODEJS_sum);

eval $plugins{'metrics'};


my @samples;
my @tsamples;

# Support a minimal subset of valid filename/path characters.
if ($DATFILE =~ /^([\.#-_\/A-Za-z0-9]+)$/) {
    $DATFILE = $1;
} else {
    die "Unable to un-taint the ysar log filename";
}

if ($opt_current) {
    if (!open(DAT,"(/usr/bin/tail -n 2 $DATFILE && $GATHER -print) |")) {
	die("$DATFILE: $!");
    }
} else {
    my $logint = 5;
    for (;;) {
	my $tail = int((($now - $start) / ($logint*60)) + 10);
	if (!open(DAT,"/usr/bin/tail -n $tail $DATFILE |")) {
	    die("$DATFILE: $!");
	}
	my $line = <DAT>;
	if (!$line) {
	    die("$DATFILE: No data collected yet");
	}
	my($t,$dat) = split('\|',$line,2);
	if ($t <= $start) {
	    last;
	}
	if ($logint == 1) {
	    last;
	}
	# go through and skip all lines to avoid having
	# write error from tail in the apache error logs
	# when we close the pipe without processing all data
	while (<DAT>) {}
	close DAT;
	$logint = 1;
    }
}

my $prev_t = 0;
my $cur_t = 0;

while (<DAT>) {
    my($t,$dat) = split('\|',$_,2);
    my $ok;
    if ($opt_current) {
	$ok = 1;
    } else {
	$ok = ($t >= $start && $t < $end);
    }
    $prev_t = $cur_t;
    $cur_t = $t;
    chomp($dat);
    my(@dat) = split('\|',$dat);
    my %dat;
    my $t_delta = $t - $t_prev;

    for $dat (@dat) {
	my($tag,$val) = split('=',$dat);
	my(@val) = split(',',$val);
	foreach (@val) {
	    if (/^(\d+)\s+0$/) {
		$_ = $1;
	    }
	}
	$dat{$tag} = \@val;
    }
    my $index;
    if ($opt_accumulate) {
	$index = (($t - $start) % $DAY_SECS) / $interval;
    } else {
	$index = ($t - $start) / $interval;
    }
    if (defined $dat{cput} and ($opt_cpushare || $opt_summary || $opt_util)) {
	$dat = $dat{cput};
	delta($dat,\@CPUT_prev);
   	if ($ok) {
	    add($index,$dat,\@CPUT_sum);
        }
    }
    if ($opt_sys || $opt_summary) {
	$dat = $dat{sys};
	delta($dat,\@SYS_prev);
	if ($ok) {
	    add($index,$dat,\@SYS_sum);
	}
    }
    if ($opt_swap || $opt_summary) {
	$dat = $dat{swap};
	delta($dat,\@SWAP_prev);
	if ($ok) {
	    add($index,$dat,\@SWAP_sum);
	}
    }
    if ($opt_fork || $opt_summary) {
	$dat = $dat{fork};
	delta($dat,\@FORK_prev);
	if ($ok) {
	    add($index,$dat,\@FORK_sum);
	}
    }
    if ($opt_tcp || $opt_udp || $opt_ip || $opt_summary) {
	$dat = $dat{ip};
	delta($dat,\@IP_prev);
	if ($ok) {
	    add($index,$dat,\@IP_sum);
	}
    }
    if ($opt_apache || $opt_summary) {
	if (!defined($opt_apache_name) || $opt_apache_name eq '') {
	    $dat = $dat{yap};
	} else {
	    my $yap_name = "yap-$opt_apache_name";
	    $dat = $dat{$yap_name};
	}
	if ($dat) {
	    if ($ok) {
		max($index,$dat,\@YAP_max);
	    }
	    delta($dat,\@YAP_prev);
	    if ($$dat[$YAP_REQUESTS] > 0 && $$dat[$YAP_RT] / $$dat[$YAP_REQUESTS] > 100000000) {
		undef $$dat[$YAP_RT];
	    }
	    if ($ok) {
		add($index,$dat,\@YAP_sum);
	    }
	}
    }
    if ($opt_yts || $opt_ytserr || $opt_ytscache || $opt_ytstls || $opt_summary) {
	$dat = $dat{yts};

	if ($dat) {
	    if (($dat->[$YTS_CUR_CLIENT_CONNS] < 0) || ($dat->[$YTS_CUR_CLIENT_CONNS] > 9999999)) {
		$dat->[$YTS_CUR_CLIENT_CONNS] = 0;
	    }
	    if (($dat->[$YTS_CUR_SERVER_CONNS] < 0) || ($dat->[$YTS_CUR_SERVER_CONNS] > 9999999)) {
		$dat->[$YTS_CUR_SERVER_CONNS] = 0;
	    }

	    if ($ok) {
		max($index,$dat,\@YTS_max);
	    }
	    if ($ok) {
		add($index,$dat,\@YTS_sum);
	    }
	    delta($dat,\@YTS_prev);
	    if ($ok) {
		if ($t_prev > 0) {
		    if (!$t_delta || (($dat->[$YTS_CLIENT_BYTES] / $t_delta) > 999*1024*1024)) { # 1000MBytes == a lot
			$dat->[$YTS_CLIENT_BYTES] = 0;
		    }
		    if (!$t_delta || (($dat->[$YTS_ORIGIN_BYTES] / $t_delta) > 999*1024*1024)) {
			$dat->[$YTS_ORIGIN_BYTES] = 0;
		    }
		    if (!$t_delta || (($dat->[$YTS_INCOMING_REQS] / $t_delta) > 999999)) {
			$dat->[$YTS_INCOMING_REQS] = 0;
		    }
		    if (!$t_delta || (($dat->[$YTS_OUTGOING_REQS] / $t_delta) > 999999)) {
			$dat->[$YTS_OUTGOING_REQS] = 0;
		    }
		    if (($dat->[$YTS_CLIENT_CONNS] < 0) || (!$t_delta) || (($dat->[$YTS_CLIENT_CONNS] / $t_delta) > 999999)) {
			$dat->[$YTS_CLIENT_CONNS] = 0;
		    }
		    if (($dat->[$YTS_SERVER_CONNS] < 0) || (!$t_delta) || (($dat->[$YTS_SERVER_CONNS] / $t_delta) > 999999)) {
			$dat->[$YTS_SERVER_CONNS] = 0;
		    }
		}
		add($index,$dat,\@YTS1_sum);
	    }
	}
    }
    if ($opt_devstat || $opt_summary || $opt_util) {
	for my $dev (keys %dat) {
	    if (index($dev,"dev.") == 0) {
		my $devname = substr($dev,4);
		$dat = $dat{$dev};
		if (!defined($DS_prev{$devname})) {
		    $DS_prev{$devname} = [];
		    $DS_sum{$devname} = [];
		}
		my $delta = [];
		lldelta($dat,$DS_prev{$devname},
			[4294967296,4294967296,4294967296,4294967296,1000000,4294967296,4294967296,4294967296,4294967296],
			$delta);
		if ($t_prev > 0
		    && $$delta[$DS_BUSY] == 0
		    && ($$delta[$DS_READS] > 10*$t_delta
			|| $$delta[$DS_WRITES] > 10*$t_delta))
		{
		    $$delta[$DS_BUSY] = $t_delta * 1000000;
		}
		if ($ok) {
		    add($index,$delta,$DS_sum{$devname});
		}
	    }
	}
    }
    if ($opt_if || $opt_summary || $opt_util) {
	for my $if (keys %dat) {
	    if ($if =~ /^if\.(.+)$/) {
		next if $1 =~ /^lo/;
		$dat = $dat{$if};
		if (!defined($IF_prev{$if})) {
		    $IF_prev{$if} = [];
		    $IF_sum{$if} = [];
		}
		delta($dat,$IF_prev{$if});
		if ($ok) {
		    add($index,$dat,$IF_sum{$if});
		}
	    }
	}
    }
    if ($opt_df || $opt_summary || $opt_util) {
	for my $df (keys %dat) {
	    if (index($df,"df/") == 0) {
		if ($ok) {
		    $dat = $dat{$df};
		    if (!defined($DF_sum{$df})) {
			$DF_sum{$df} = [];
		    }
		    add($index,$dat,$DF_sum{$df});
		}
	    }
	}
    }
    if ($opt_innodb || $opt_mysql || $opt_summary) {
	$dat = $dat{mysql};
	if ($dat) {
	    $$dat[$MYSQL_CONNECTIONS]--;
	    $$dat[$MYSQL_THREADS_RUNNING]--;
	    if ($ok) {
		add($index,$dat,\@MYSQL_ssum);
	    }
	    if (@MYSQL_prev > 0
		&& $$dat[$MYSQL_CONNECTIONS] >= $MYSQL_prev[$MYSQL_CONNECTIONS]
		&& $$dat[$MYSQL_QUESTIONS] >= $MYSQL_prev[$MYSQL_QUESTIONS]
		&& $$dat[$MYSQL_SLOW_QUERIES] >= $MYSQL_prev[$MYSQL_SLOW_QUERIES]
	    ) {
		delta($dat,\@MYSQL_prev);
	    } else {
		@MYSQL_prev = @$dat;
	    }
	    if ($ok) {
		add($index,$dat,\@MYSQL_sum);
	    }
	}
    }
    if ($opt_ysquid || $opt_ysquidhealth) {
        $dat = $dat{ysquid};
        if ($dat) {
            if ($ok) {
                add($index,$dat,\@YSQUID_ssum);
            }
            if (!defined($YSQUID_prev[$YSQUID_REQUESTS])) {
                @YSQUID_prev = @$dat;
            } else {
                if (@YSQUID_prev > 0) {
                    delta($dat,\@YSQUID_prev);
                } else {
                    @YSQUID_prev = @$dat;
                }
                if ($ok) {
                    add($index,$dat,\@YSQUID_sum);
                }
            }
        }
    }
    if ($opt_nfsrops || $opt_nfswops || $opt_nfscache || $opt_nfsopx) {
	if ($os eq "freebsd") {
	    $dat = $dat{nfs};
	    if ($dat) {
		delta($dat,\@NFS_prev);
		if ($ok) {
		    add($index,$dat,\@NFS_sum);
		}
	    }
	} else {
	    for my $nfs_mount (keys %dat) {
		if (index($nfs_mount,"nfs.") == 0) {
		    my $mount = substr($nfs_mount,4);
		    $dat = $dat{$nfs_mount};
		    if ($dat) {
			if (!defined($NFS_LX_prev{$mount})) {
			    $NFS_LX_prev{$mount} = [];
			    $NFS_LX_sum{$mount} = [];
			}
			delta($dat,$NFS_LX_prev{$mount});
			if ($ok) {
			    add($index,$dat,$NFS_LX_sum{$mount});
			}
		    }
		}
	    }
	}
    }
    if ($opt_ciss) {
	$dat = $dat{ciss};
	if ($dat) {
	    delta($dat,\@CISS_prev);
	    if ($ok) {
		add($index,$dat,\@CISS_sum);
	    }
	}
	$dat = $dat{ciss1};
	if ($dat) {
	    delta($dat,\@CISS1_prev);
	    if ($ok) {
		add($index,$dat,\@CISS1_sum);
	    }
	}
	for my $v (keys %dat) {
	    if ($v =~ /^ciss\..+/) {
		$dat = $dat{$v};
		if (!defined($CISS_prev{$v})) {
		    $CISS_prev{$v} = [];
		    $CISS_sum{$v} = [];
		}
		delta($dat,$CISS_prev{$v});
		if ($ok) {
		    add($index,$dat,$CISS_sum{$v});
		}
	    } elsif ($v =~ /^cissd\..+/) {
		$dat = $dat{$v};
		if (!defined($CISSD_prev{$v})) {
		    $CISSD_prev{$v} = [];
		    $CISSD_sum{$v} = [];
		}
		delta($dat,$CISSD_prev{$v});
		if ($ok) {
		    add($index,$dat,$CISSD_sum{$v});
		}
	    }
	}
    }
    if ($opt_kmem) {
	$dat = $dat{kmem};
	if ($dat && $ok) {
	    add($index,$dat,\@KMEM_sum);
	}
    }
    if ($opt_tcpx) {
	$dat = $dat{tcp};
	if ($dat) {
	    if ($ok) {
		add($index,$dat,\@TCP_sum);
	    }
	    delta($dat,\@TCP_prev);
	    if ($ok) {
		add($index,$dat,\@TCP1_sum);
	    }
	}
    }
    if ( $opt_shmproxy_que or $opt_shmproxy_drops or $opt_shmproxy_ci or $opt_shmproxy_co
        or $opt_shmproxy_pi or $opt_shmproxy_po or $opt_shmproxy_rd ){
      for my $port (keys %dat) {
          if ($port =~ /^shmproxy\.(.+)$/) {
              $dat = $dat{$port};
              if (!defined($SHMP_prev{$port})) {
                  $SHMP_prev{$port} = [];
                  $SHMP_sum{$port} = [];
              }
              delta($dat,$SHMP_prev{$port});
              clamp($dat,'0',undef);
              # do beter filtering for monotonic data streams.
              if ($ok) {
                  add($index,$dat,$SHMP_sum{$port});
              }
           }
        }
    } 
    eval $plugins{'dat'};
    if ($ok) {
	if ($opt_mem || $opt_summary || $opt_util) {
	    $dat = $dat{mem};
	    add($index,$dat,\@MEM_sum);
	}
	if ($opt_memx) {
	    $dat = $dat{memx};
	    if ($dat) {
		add($index,$dat,\@MEMX_sum);
	    }
	}
	if ($opt_load) {
	    $dat = $dat{load};
	    add($index,$dat,\@LD_sum);
	}
	if ($opt_ps) {
	    $dat = $dat{ps};
	    add($index,$dat,\@PS_sum);
	}
	if ($opt_ynodejs) {
	    $dat = $dat{ynodejs};
	    if ($dat) {
		add($index,$dat,\@YNODEJS_sum);
	    }
	}
	$samples[$index]++;
	if ($t_prev > 0) {
	    $tsamples[$index] += $t_delta;
	} else {
	    $tsamples[$index] = 0;
	}
    }
    $t_prev = $t;
}

open(OUT,">-");
if ($cgi) {
    my $type = $opt_raw ? "text/plain" : "text/html";
    print OUT $cgi->header(-type => $type);
    if (!$opt_raw) {
	print OUT $cgi->start_html("System Activity");
	print OUT "<pre>\n";
    }
}


my(@CPUT_stats,@LD_stats,@MEM_stats,@PS_stats,@SYS_stats,@SWAP_stats,@FORK_stats,
   @TCP_stats,@UDP_stats,@IP_stats,%DS_stats,%IF_stats,@YTSTLS_stats,
   @SUMMARY_stats,@UTIL_stats,@YAP_stats,@YTS_stats,@YTSERR_stats,@YTSCACHE_stats,
   %DF_stats,@MYSQL_stats,@NFSROPS_stats,@NFSWOPS_stats,@NFSCACHE_stats,@CISS_stats,
   @YSQUID_stats,@YSQUIDHEALTH_stats,
   %CISS_stats,@KMEM_stats, @TCPX_stats, %SHMP_stats,@YNODEJS_stats,@MEMX_stats,
   @NFS_LX_stats);

eval $plugins{'stats'};

my($STAT_SUM,$STAT_SAMPLES,$STAT_MIN,$STAT_MAX,$STAT_WIDTH,$STAT_MINTIME,$STAT_MAXTIME,
   $STAT_MAXBASE) = (0,1,2,3,4,5,6,7);

my $outbuf;
my $outstats;
my $hdrbuf = '';
my $outlines = 0;

my %IF_media;
my $CPU_speed = 0;
my $CPU_count = 0;

if ($opt_util) {
    if ($os eq "freebsd") {
	my(@ifconfig) = `/sbin/ifconfig`;
	my $if;
	for (@ifconfig) {
	    if (/media:.*[^0-9]([0-9]+)baseTX/) {
		$IF_media{$if} = $1;
	    } elsif (/^([^: \t]+):/) {
		$if = $1;
		$IF_media{$if} = 1000;
	    }
	}

	my(@dmesg) = `/usr/bin/egrep ^CPU: /var/run/dmesg.boot`;
	for (@dmesg) {
	    if (/([0-9.]+)-MHz.*CPU/) {
		$CPU_speed = $1;
	    }
	}

	$CPU_count = `/sbin/sysctl -n hw.ncpu`;
    }
    if ($os eq "rhel") {
	if (open(F,"/proc/net/dev")) {
	    while (<F>) {
		if (/^\s*([^ :]+):/) {
		    my $eth_id = $1;
		    my $link_speed = 0;
		    if ($eth_id =~ /eth\d+/) {

			# first look for /sys/class/net/eth0/speed contents
			# which is only valid for rhel6 systems

			if (open(ETH_SPEED,"/sys/class/net/$eth_id/speed")) {
			    while (<ETH_SPEED>) {
				my $speed_line = $_;
				chomp($speed_line);
				if ($speed_line =~ /^(\d+)$/) {
				    $link_speed = $1;
				}
			    }
			    close(ETH_SPEED);
			}
			
			# if we have nothing then look at the dmesg output
			# which may be missing the info since it could have
			# been removed from dmesg buffer

			if ($link_speed == 0) {
			    my(@linksp) = `/bin/dmesg | grep $eth_id | grep -i Link`;
			    for (@linksp) {
				if (/(\d+) Mbps/) {
				    $link_speed = $1;
				}
			    }
			}
		    }

		    # if still no valid then default to 100
		    
		    if ($link_speed == 0) {
			$link_speed = 100;
		    }
		    
		    $IF_media{$eth_id} = $link_speed;
		}
	    }
	    close(F);
	}

	if (open(F,"/proc/cpuinfo")) {
	    while (<F>) {
		if (/^cpu MHz\s*:\s*([0-9.]+)/) {
		    $CPU_speed = $1;
		} elsif (/^processor\s*:\s*(\d+)/) {
		    $CPU_count++;
		}
	    }
	    close(F);
	}
    }
}

for (my $i = 0; $i < @tsamples; $i++) {
    $outbuf = '';
    $outstats = 0;
    if (($hdrint == 0 && $outlines == 0)
	|| ($hdrint > 0) && (($outlines % $hdrint) == 0))
    {
	print_header();
	$hdrbuf = $outbuf;
	$outbuf = '';
    }
    if ($opt_current) {
	$outbuf .= $now;
    } elsif ($opt_day) {
	$outbuf .= strftime("%m/%d       ",localtime($start + $i*$interval));
    } elsif ($opt_accumulate) {
	$outbuf .= sprintf("%02d:%02d       ",
			   $i*$interval/(60*60),$i*$interval%(60*60)/60);
    } else {
	$outbuf .= strftime("%m/%d-%H:%M ",localtime($start + $i*$interval));
    }
    if ($opt_summary) {
	my $stat = 0;
	my $pv;
	my @vals;

	my $l = $YAP_sum[$i];
	my $nreq = $l ? $$l[$YAP_REQUESTS] : 0;
	undef($pv);
	if ($l) {
	    $pv = $tsamples[$i] ? $nreq / $tsamples[$i] : 0;
	}
	show_val($pv,\@SUMMARY_stats,$stat++,6);
	push(@vals,$pv);

	undef($pv);
	if ($l && $nreq && defined($$l[$YAP_RT])) {
	    $pv = $$l[$YAP_RT] / $nreq / 1000;
	}
	show_val($pv,\@SUMMARY_stats,$stat++,8);
	push(@vals,$pv);

	$l = $CPUT_sum[$i];
	undef($pv);
	if ($l) {
	    my $sum = 0;
	    map { $sum += $_ } @$l;
	    if ($sum) {
		$pv = ($$l[$CP_USER] + $$l[$CP_SYS] + $$l[$CP_INTR])/$sum * 100;
	    } else {
		$pv = 0;
	    }
	}
	show_val($pv,\@SUMMARY_stats,$stat++,6);
	push(@vals,$pv);

	$l = $MEM_sum[$i];
	undef($pv);
	if ($l and defined $$l[$MEM_ACTIVE] and defined $$l[$MEM_WIRED] and defined  $$l[$MEM_TOTAL]) {
	    $pv = ($$l[$MEM_ACTIVE] + $$l[$MEM_WIRED]) / $$l[$MEM_TOTAL] * 100;
	}
	show_val($pv,\@SUMMARY_stats,$stat++,6);
	push(@vals,$pv);

	my $l1 = $SWAP_sum[$i];
	undef($pv);
	if ($l1 && $l and defined $$l1[$SWAP_PGSOUT]  and defined $$l[$MEM_TOTAL]) {
	    $pv = $$l1[$SWAP_PGSOUT] / $$l[$MEM_TOTAL] * 100;
	}
	show_val($pv,\@SUMMARY_stats,$stat++,6);
	push(@vals,$pv);

	$l = $SYS_sum[$i];
	$l1 = $IP_sum[$i];
	my $npkts;
	if ($l1) {
	    $npkts = $$l1[$IP_SENDPKT] + $$l1[$IP_RECVPKT];
	}
	undef($pv);
	if ($l) {
	    $pv = $npkts ? $$l[$SYS_SYSCALL] / $npkts : 0;
	}
	show_val($pv,\@SUMMARY_stats,$stat++,7);
	push(@vals,$pv);

	undef($pv);
	if ($l) {
	    $pv = $npkts ? $$l[$SYS_SWTCH] / $npkts : 0;
	}
	show_val($pv,\@SUMMARY_stats,$stat++,6);
	push(@vals,$pv);

	for my $dev (sort keys %DS_sum) {
	    $l = $DS_sum{$dev};
	    $l = $$l[$i];
	    undef($pv);
	    if ($l && $tsamples[$i]) {
		$pv = $$l[$DS_BUSY] / ($tsamples[$i]*10000);
	    }
	    show_val($pv,\@SUMMARY_stats,$stat++,6);
	    push(@vals,$pv);
	}

	for my $df (sort keys %DF_sum) {
	    $l = $DF_sum{$df};
	    $l = $$l[$i];
	    undef($pv);
	    if ($l && $tsamples[$i]) {
		if ($$l[$DF_TOTAL]) {
		    $pv = $$l[$DF_USED] / $$l[$DF_TOTAL] * 100;
		} else {
		    $pv = 0;
		}
	    }
	    show_val($pv,\@SUMMARY_stats,$stat++,6);
	    push(@vals,$pv);
	}

	for my $if (keys %IF_sum) {
	    $l = $IF_sum{$if};
	    $l = $$l[$i];
	    undef($pv);
	    if ($l && $tsamples[$i]) {
		$pv = $$l[$IF_RECVBYTE] / ($tsamples[$i]*1000) * 8;
	    }
	    show_val($pv,\@SUMMARY_stats,$stat++,8);
	    push(@vals,$pv);

	    undef($pv);
	    if ($l && $tsamples[$i]) {
		$pv = $$l[$IF_SENDBYTE] / ($tsamples[$i]*1000) * 8;
	    }
	    show_val($pv,\@SUMMARY_stats,$stat++,8);
	    push(@vals,$pv);
	}

	add_sum_stats($start + $i*$interval,\@vals,\@SUMMARY_stats);
    }
    if ($opt_util) {
	my $stat = 0;
	my $pv;
	my $l;

	my $cpu = 0;
	$l = $CPUT_sum[$i];
	undef($pv);
	if ($l) {
	    my $sum = 0;
	    map { $sum += $_ } @$l;
	    if ($sum) {
		$pv = ($$l[$CP_USER] + $$l[$CP_SYS] + $$l[$CP_INTR])/$sum;
		$cpu = $pv;
		$pv *= 100;
	    } else {
		$pv = 0;
	    }
	}
	show_val($pv,\@UTIL_stats,$stat++,6);

	$l = $MEM_sum[$i];
	undef($pv);
	if ($l) {
	    $pv = ($$l[$MEM_ACTIVE] + $$l[$MEM_WIRED]) / $$l[$MEM_TOTAL] * 100;
	}
	show_val($pv,\@UTIL_stats,$stat++,6);

	for my $dev (sort keys %DS_sum) {
	    $l = $DS_sum{$dev};
	    $l = $$l[$i];
	    undef($pv);
	    if ($l && $tsamples[$i]) {
		$pv = $$l[$DS_BUSY] / ($tsamples[$i]*10000);
	    }
	    show_val($pv,\@UTIL_stats,$stat++,6);
	}

	for my $df (sort keys %DF_sum) {
	    $l = $DF_sum{$df};
	    $l = $$l[$i];
	    undef($pv);
	    if ($l && $tsamples[$i]) {
		if ($$l[$DF_TOTAL]) {
		    $pv = $$l[$DF_USED] / $$l[$DF_TOTAL] * 100;
		} else {
		    $pv = 0;
		}
	    }
	    show_val($pv,\@UTIL_stats,$stat++,6);
	}

	my $netsum = 0;
	for my $if (keys %IF_sum) {
	    $l = $IF_sum{$if};
	    $l = $$l[$i];
	    undef($pv);
	    my $speed = $IF_media{substr($if,3)} * 1000000;
	    if ($l && $tsamples[$i]) {
		$pv = $$l[$IF_RECVBYTE] / $tsamples[$i] * 8;
		$netsum += $pv;
		$pv = $pv / $speed * 100;
	    }
	    show_val($pv,\@UTIL_stats,$stat++,6);

	    undef($pv);
	    if ($l && $tsamples[$i]) {
		$pv = $$l[$IF_SENDBYTE] / $tsamples[$i] * 8;
		$netsum += $pv;
		$pv = $pv / $speed * 100;
	    }
	    show_val($pv,\@UTIL_stats,$stat++,6);
	}

	if ($cpu * $CPU_speed * $CPU_count) {
	    $pv = ($netsum / 1000) / ($cpu * $CPU_speed * $CPU_count);
	} else {
	    undef($pv);
	}
	show_val2($pv,\@UTIL_stats,$stat++,7);
    }
    if ($opt_apache) {
	my $stat = 0;
	show_avg(6,$i,$tsamples[$i],1,\@YAP_sum,\@YAP_stats,$stat++,
		 $YAP_REQUESTS);
	my $sum = $YAP_sum[$i];
	my $nreq = 0;
	if ($sum && $YAP_REQUESTS < @$sum) {
	    $nreq = $$sum[$YAP_REQUESTS];
	}
        my $pv;
        if ($sum && $nreq && defined($$sum[$YAP_RT])) {
            $pv = $$sum[$YAP_RT] / $nreq / 1000;
        }
        show_val($pv,\@YAP_stats,$stat++,9);

	show_avg(7,$i,$nreq,1000,\@YAP_sum,\@YAP_stats,$stat,$YAP_BYTES_IN,$YAP_BYTES_OUT);
	$stat += 2;

	if ($sum) {
	    $pv = $nreq ? $$sum[$YAP_ACTIVE_CHILDREN] / $nreq : 0;
	}
	show_val($pv,\@YAP_stats,$stat++,6);

	my $max = $YAP_max[$i];
	undef($pv);
	if ($max) {
	    $pv = $$max[$YAP_MAX_ACTIVE_CHILDREN];
	}
	show_val($pv,\@YAP_stats,$stat++,6);
    }
    if ($opt_yts) {
	my $stat = 0;
	my $l = $YTS_sum[$i];
	my $l1 = $YTS1_sum[$i];
	my $div = $tsamples[$i] ? $tsamples[$i] / 60 : 0;
	my $pv;

	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTS_stats,$stat++,$YTS_INCOMING_REQS);
	undef($pv);
	if ($l && $$l[$YTS_CUR_CLIENT_CONNS]) {
	    $pv = $div ? $$l[$YTS_CUR_CLIENT_CONNS] / $div : 0;
	}
	show_intval($pv,\@YTS_stats,$stat++,8);
	undef($pv);
	if ($l1 && $$l1[$YTS_CLIENT_CONNS] && $$l1[$YTS_INCOMING_REQS]) {
	    $pv = $$l1[$YTS_INCOMING_REQS] / $$l1[$YTS_CLIENT_CONNS];
	}
	show_val($pv,\@YTS_stats,$stat++,8);
	show_avg(8,$i,$tsamples[$i],1048576/8,\@YTS1_sum,\@YTS_stats,$stat++,$YTS_CLIENT_BYTES);
	undef($pv);
	if ($l1 && (($$l1[$YTS_CACHE_HITS] && $$l1[$YTS_CACHE_HITS_T]) ||
                    ($$l1[$YTS_CACHE_MISSES] && $$l1[$YTS_CACHE_MISSES_T]))) {
	    $pv = 1000*($$l1[$YTS_CACHE_HITS_T] + $$l1[$YTS_CACHE_MISSES_T]) /
	      ($$l1[$YTS_CACHE_HITS] + $$l1[$YTS_CACHE_MISSES]);
	}
	show_val($pv,\@YTS_stats,$stat++,8);

	show_avg(10,$i,$tsamples[$i],1,\@YTS1_sum,\@YTS_stats,$stat++,$YTS_OUTGOING_REQS);
	undef($pv);
	if ($l && $$l[$YTS_CUR_SERVER_CONNS]) {
	    $pv = $div ? $$l[$YTS_CUR_SERVER_CONNS] / $div : 0;
	}
	show_intval($pv,\@YTS_stats,$stat++,8);
	undef($pv);
	if ($l1 && $$l1[$YTS_SERVER_CONNS] && $$l1[$YTS_OUTGOING_REQS]) {
	    $pv = $$l1[$YTS_OUTGOING_REQS] / $$l1[$YTS_SERVER_CONNS];
	}
	show_val($pv,\@YTS_stats,$stat++,8);
	show_avg(8,$i,$tsamples[$i],1048576/8,\@YTS1_sum,\@YTS_stats,$stat++,$YTS_ORIGIN_BYTES);
    }
    if ($opt_ytscache) {
	my $stat = 0;
	my $l = $YTS_sum[$i];
	my $l1 = $YTS1_sum[$i];
	my $div = $tsamples[$i] ? $tsamples[$i] / 60 : 0;
	my $pv;

	show_ratio_1(10,$i,\@YTS1_sum,\@YTSCACHE_stats,$stat++,
		     $YTS_CACHE_HITS, $YTS_CACHE_MISSES);
	show_ratio_1(9,$i,\@YTS1_sum,\@YTSCACHE_stats,$stat++,
		     $YTS_RAM_CACHE_HITS, $YTS_RAM_CACHE_MISSES);
	undef($pv);
	if ($l && $$l[$YTS_ACTIVE_IN_CACHE]) {
	    $pv = $div ? $$l[$YTS_ACTIVE_IN_CACHE] / $div : 0;
	}
	show_intval($pv,\@YTSCACHE_stats,$stat++,8);
	undef($pv);
	if ($l1 && $$l1[$YTS_CACHE_HITS] && $$l1[$YTS_CACHE_HITS_T]) {
	    $pv = 1000*$$l1[$YTS_CACHE_HITS_T] / $$l1[$YTS_CACHE_HITS];
	}
	show_val($pv,\@YTSCACHE_stats,$stat++,8);
	undef($pv);
	if ($l1 && $$l1[$YTS_CACHE_MISSES] && $$l1[$YTS_CACHE_MISSES_T]) {
	    $pv = 1000*$$l1[$YTS_CACHE_MISSES_T] / $$l1[$YTS_CACHE_MISSES];
	}
	show_val($pv,\@YTSCACHE_stats,$stat++,8);
	show_avg(7,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSCACHE_stats,$stat++,$YTS_CACHE_READ_ERR);
	show_avg(7,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSCACHE_stats,$stat++,$YTS_CACHE_WRITE_ERR);
    }
    if ($opt_ytserr) {
	my $stat = 0;

	show_avg(10,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSERR_stats,$stat++,$YTS_MISSING_HOST);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSERR_stats,$stat++,
		 $YTS_ABORTS,$YTS_HANGUPS);
	show_avg(11,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSERR_stats,$stat++,$YTS_CONNECT_FAIL);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSERR_stats,$stat++,$YTS_ERR_OTHER);
    }
    if ($opt_ytstls) {
	my $stat = 0;

	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_OTHER);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_EXPIRED);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_REVOKED);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_UNKNOWN);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_VERIFY);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_BADCERT);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_DECRYPT);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_VERSION);
	show_avg(8,$i,$tsamples[$i],1,\@YTS1_sum,\@YTSTLS_stats,$stat++,$YTS_UA_TLS_UNKNOWNCA);
    }
    if ($opt_cpushare) {
	show_share($i,\@CPUT_sum,\@CPUT_stats,0);
    }
    if ($opt_mem) {
	show_avg(9,$i,$samples[$i],1024/4,\@MEM_sum,\@MEM_stats,0,
		 $MEM_ACTIVE,$MEM_INACTIVE,$MEM_CACHED,$MEM_FREE,$MEM_WIRED);
    }
    if ($opt_memx) {
	show_avg(9,$i,$samples[$i],1024,\@MEMX_sum,\@MEMX_stats,0,
		 $MEMX_BUFFERS,$MEMX_CACHED,$MEMX_SWAP_TOTAL,$MEMX_SWAP_FREE,
		 $MEMX_HP_TOTAL,$MEMX_HP_FREE,$MEMX_HP_RSVD,
		 $MEMX_HP_SURP,$MEMX_HP_SIZE);
    }
    if ($opt_load) {
	show_avg(6,$i,$samples[$i],1,\@LD_sum,\@LD_stats,0,
		 $LD_1M, $LD_5M, $LD_15M);
    }
    if ($opt_ps) {
	show_avg(6,$i,$samples[$i],1,\@PS_sum,\@PS_stats,0,
		 $PS_RUN,$PS_SLEEP,$PS_IDLE,$PS_DISK);
    }
    if ($opt_sys) {
	show_avg(7,$i,$tsamples[$i],1000,\@SYS_sum,\@SYS_stats,0,
		 $SYS_SWTCH,$SYS_SYSCALL,$SYS_INTR);
    }
    if ($opt_swap) {
	show_avg(7,$i,$tsamples[$i],1,\@SWAP_sum,\@SWAP_stats,0,
		 $SWAP_PGSOUT,$SWAP_VNODEPGSOUT,$SWAP_PGSIN,$SWAP_VNODEPGSIN);
    }
    if ($opt_fork) {
	show_avg(6,$i,$tsamples[$i],1,\@FORK_sum,\@FORK_stats,0,
		 $FORK_FORKS,$FORK_VFORKS);
    }
    if ($opt_tcp) {
	my $stat = 0;
	show_avg(8,$i,$tsamples[$i],1000,\@IP_sum,\@TCP_stats,$stat,
		 $IP_TCPRECVPKT,$IP_TCPRECVBYTE,
		 $IP_TCPSENDPKT,$IP_TCPSENDBYTE);
	$stat += 4;
	show_ratio(6,$i,\@IP_sum,\@TCP_stats,$stat,
		   $IP_TCPREXMITPKT,$IP_TCPSENDPKT,
		   $IP_TCPREXMITBYTE,$IP_TCPSENDBYTE);
	$stat += 2;
	show_avg(7,$i,$tsamples[$i],1000,\@IP_sum,\@TCP_stats,$stat,
		 $IP_TCPSYNCADD,$IP_TCPSYNCCO,$IP_TCPSYNCBO);
	$stat += 3;
    }
    if ($opt_udp) {
	my $stat = 0;
	show_avg(7,$i,$tsamples[$i],1000,\@IP_sum,\@UDP_stats,$stat,
		 $IP_UDPRECVPKT,$IP_UDPSENDPKT);
	$stat += 2;
	show_ratio(6,$i,\@IP_sum,\@UDP_stats,$stat++,
		   $IP_UDPDROPPED,$IP_UDPRECVPKT);
    }
    if ($opt_ip) {
	show_avg(7,$i,$tsamples[$i],1000,\@IP_sum,\@IP_stats,0,
		 $IP_RECVPKT,$IP_SENDPKT);
    }
    if ($opt_devstat) {
	for my $dev (sort keys %DS_sum) {
	    my $pv;
	    my $l = $DS_sum{$dev};
	    $l = $$l[$i];
	    if (!defined($DS_stats{$dev})) {
		$DS_stats{$dev} = [];
	    }
	    if ($os eq "rhel") {
		my $stat = 0;
		show_avg_w($i,$tsamples[$i],[1,1000,1,1000,10000,1000],
			   $DS_sum{$dev},$DS_stats{$dev},0,
			   $DS_READS,7,
			   $DS_RBYTES,9,
			   $DS_WRITES,7,
			   $DS_WBYTES,9,
			   $DS_BUSY,6,
			   $DS_QUEUE,7);
		$stat += 6;
		undef($pv);
		$pv = $$l[$DS_NIOS] ? $$l[$DS_NTICKS] / $$l[$DS_NIOS] : 0;
		show_val($pv,$DS_stats{$dev},$stat++,7);
		undef($pv);
		$pv = $$l[$DS_NIOS] ? $$l[$DS_BIOTICKS] / $$l[$DS_NIOS] : 0;
		show_val($pv,$DS_stats{$dev},$stat++,7);
	    } else {
		show_avg_w($i,$tsamples[$i],[1,1000,1,1000,10000],
			   $DS_sum{$dev},$DS_stats{$dev},0,
			   $DS_READS,7,
			   $DS_RBYTES,9,
			   $DS_WRITES,7,
			   $DS_WBYTES,9,
			   $DS_BUSY,6);
	    }
	}
    }
    if ($opt_if) {
	for my $if (keys %IF_sum) {
	    if (!defined($IF_stats{$if})) {
		$IF_stats{$if} = [];
	    }
	    show_avg(7,$i,$tsamples[$i],[1000,1000,1000,1000,1,1,1],$IF_sum{$if},$IF_stats{$if},0,
		     $IF_RECVPKT,$IF_RECVBYTE,$IF_SENDPKT,$IF_SENDBYTE,
		     $IF_IERRS,$IF_OERRS,$IF_COLL);
	}
    }
    if ($opt_df) {
	for my $df (keys %DF_sum) {
	    if (!defined($DF_stats{$df})) {
		$DF_stats{$df} = [];
	    }
	    show_ratio(11,$i,$DF_sum{$df},$DF_stats{$df},0,
		       $DF_USED,$DF_TOTAL);
	}
    }
    if ($opt_mysql) {
	my $stat = 0;
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],7,1,$stat,
		 $MYSQL_CONNECTIONS,$MYSQL_QUESTIONS);
	$stat += 2;
	show_bytes_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],8,1,$stat,
		 $MYSQL_BYTES_RECEIVED,$MYSQL_BYTES_SENT);
	$stat += 2;
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],7,1,$stat,
		 $MYSQL_SELECTS,$MYSQL_INSERTS,$MYSQL_UPDATES,$MYSQL_DELETES);
	$stat += 4;

	my $l = $MYSQL_sum[$i];
	my $pv;

	undef($pv);
	if ($l && $$l[$MYSQL_SLOW_QUERIES]) {
	    $pv = $$l[$MYSQL_SLOW_QUERIES];
	}
	show_intval($pv,\@MYSQL_stats,$stat++,5);

	show_avg(6,$i,$samples[$i],1,\@MYSQL_ssum,\@MYSQL_stats,$stat,
		 $MYSQL_THREADS_CONNECTED,$MYSQL_THREADS_RUNNING);
	$stat += 2;

	undef($pv);
	if ($l && $$l[$MYSQL_KEY_READ_REQUESTS]) {
	    $pv = 100*$$l[$MYSQL_KEY_READS]/$$l[$MYSQL_KEY_READ_REQUESTS];
	}
	show_val($pv,\@MYSQL_stats,$stat++,6);

	undef($pv);
	if ($l) {
	    my $locks = $$l[$MYSQL_TABLE_LOCKS_IMMEDIATE] + $$l[$MYSQL_TABLE_LOCKS_WAITED];
	    if ($locks) {
		$pv = 100*$$l[$MYSQL_TABLE_LOCKS_WAITED]/$locks;
	    }
	}
	show_val($pv,\@MYSQL_stats,$stat++,6);

	undef($pv);
	if ($l) {
	    my $q = $$l[$MYSQL_QCACHE_INSERTS] + $$l[$MYSQL_QCACHE_HITS]
		+ $$l[$MYSQL_QCACHE_NOT_CACHED];
	    $pv = $q ? 100*(1-$$l[$MYSQL_QCACHE_HITS]/$q) : 0;
	}
	show_val($pv,\@MYSQL_stats,$stat++,6);

	$l = $MYSQL_ssum[$i];
	undef($pv);
	if ($l) {
	    $pv = $$l[$MYSQL_QUERY_CACHE_SIZE]
		? (100 * (1-($$l[$MYSQL_QCACHE_FREE_MEMORY]/$$l[$MYSQL_QUERY_CACHE_SIZE])))
		: 0;
	}
	show_val($pv,\@MYSQL_stats,$stat++,6);

	undef($pv);
	if ($l) {
	    $pv = $$l[$MYSQL_REPL_DELAY] / $samples[$i];
	}
	show_val($pv,\@MYSQL_stats,$stat++,6);
    }
    if ($opt_ysquid) {
        my $stat = 0;
        my $pv;
        my $l = $YSQUID_ssum[$i];

        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUID_stats,$tsamples[$i],6,0,$stat,
			$YSQUID_REQUESTS);
        $stat += 1;

        show_ratio_4(5,$i,\@YSQUID_ssum,\@YSQUID_stats,$stat,
		     $YSQUID_HITS,$YSQUID_REQUESTS);
        $stat += 1;

        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUID_stats,$$l[$YSQUID_HITS],5,0,$stat,
			$YSQUID_RT_HIT);
        $stat += 1;

        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUID_stats,$$l[$YSQUID_MISSES],5,0,$stat,
			$YSQUID_RT_MISS);
        $stat += 1;

        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUID_stats,$samples[$i],6,0,$stat,
			$YSQUID_MEDIAN_RT_HIT);
        $stat += 1;
        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUID_stats,$samples[$i],5,0,$stat,
			$YSQUID_MEDIAN_RT_MISS);
        $stat += 1;

        show_ratio_4(5,$i,\@YSQUID_ssum,\@YSQUID_stats,$stat,
		     $YSQUID_TCP_MEM_HIT,$YSQUID_REQUESTS,
		     $YSQUID_TCP_HIT,$YSQUID_REQUESTS,
		     $YSQUID_TCP_IMS_HIT,$YSQUID_REQUESTS,
		     $YSQUID_TCP_STALE_HIT,$YSQUID_REQUESTS,
		     $YSQUID_TCP_ASYNC_HIT,$YSQUID_REQUESTS,
		     $YSQUID_TCP_MISS,$YSQUID_REQUESTS,
		     $YSQUID_TCP_REFRESH_MISS,$YSQUID_REQUESTS,
		     $YSQUID_TCP_CLIENT_REFRESH_MISS,$YSQUID_REQUESTS,
		     $YSQUID_TCP_ASYNC_MISS,$YSQUID_REQUESTS);
        $stat += 9;
    }
    if ($opt_ysquidhealth) {
        my $stat = 0;
        my $pv;
        my $l = $YSQUID_ssum[$i];

        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUIDHEALTH_stats,$tsamples[$i],5,0,$stat++,
			$YSQUID_REQUESTS);

        show_ratio_4(5,$i,\@YSQUID_ssum,\@YSQUIDHEALTH_stats,$stat++,
		     $YSQUID_HITS,$YSQUID_REQUESTS);
        
        show_bytes_avg(\@YSQUID_ssum,$i,\@YSQUIDHEALTH_stats,1/1024*$samples[$i],6,0,
		       $stat++,$YSQUID_MEMSIZE);
        show_bytes_avg(\@YSQUID_ssum,$i,\@YSQUIDHEALTH_stats,1/1024*$samples[$i],6,0,
		       $stat++,$YSQUID_STORE_MEM_SIZE);
        show_bytes_avg(\@YSQUID_ssum,$i,\@YSQUIDHEALTH_stats,1/1024*$samples[$i],6,0,
		       $stat++,$YSQUID_STORE_DISK_SIZE);
        
        undef($pv);
        if ($l && $$l[$YSQUID_FD_USED]) {
            $pv = $$l[$YSQUID_FD_USED] / $samples[$i];
        }
        show_intval($pv,\@YSQUIDHEALTH_stats,$stat++,6);

        undef($pv);
        if ($l && $$l[$YSQUID_STORE_FILES_OPEN]) {
            $pv = $$l[$YSQUID_STORE_FILES_OPEN] / $samples[$i];
        }
        show_intval($pv,\@YSQUIDHEALTH_stats,$stat++,6);

        show_simple_avg(\@YSQUID_ssum,$i,\@YSQUIDHEALTH_stats,$samples[$i],6,0,$stat++,
			$YSQUID_PAGE_FAULTS);

        show_bytes_avg(\@YSQUID_sum,$i,\@YSQUIDHEALTH_stats,1/1024*$tsamples[$i],6,0,$stat++,
		       $YSQUID_CLIENT_HTTP_KBOUT);

        show_bytes_avg(\@YSQUID_sum,$i,\@YSQUIDHEALTH_stats,1/1024*$tsamples[$i],6,0,$stat,
		       $YSQUID_ICP_KBSENT,$YSQUID_ICP_KBRECV);
        $stat += 2;
    }
    if ($opt_innodb) {

	my $stat = 0;
    
	# Row operations
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
			$MYSQL_Innodb_rows_read,$MYSQL_Innodb_rows_inserted,
			$MYSQL_Innodb_rows_updated,$MYSQL_Innodb_rows_deleted,
	    );
	$stat += 4;
	
	# Buffer pool
	# Logical vs physical reads
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
			$MYSQL_Innodb_pages_created,$MYSQL_Innodb_buffer_pool_read_requests );
	$stat += 2;
	
	# % of physical I/O reads
	my $l = $MYSQL_sum[$i];
	my $pv;
	undef( $pv );
	if ($l) {
	    $pv = $$l[$MYSQL_Innodb_buffer_pool_read_requests]
		? (100 * ($$l[$MYSQL_Innodb_buffer_pool_reads]
            / $$l[$MYSQL_Innodb_buffer_pool_read_requests]))
		: 0;
	}
	show_pct($pv,\@MYSQL_stats,$stat++,5);
	# Writes
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
			$MYSQL_Innodb_buffer_pool_write_requests );
	$stat += 1;
	
	# % of physical I/O writes
	undef( $pv );
	if ($l) {
	    $pv = $$l[$MYSQL_Innodb_buffer_pool_write_requests]
		? (100 * ($$l[$MYSQL_Innodb_buffer_pool_pages_flushed]
			  / $$l[$MYSQL_Innodb_buffer_pool_write_requests]))
		: 0;
	}
	show_pct($pv,\@MYSQL_stats,$stat++,5);

	# Dirty pool
	$l = $MYSQL_ssum[$i];
	undef($pv);
	if ($l) {
	    $pv = $$l[$MYSQL_Innodb_buffer_pool_pages_data]
		? (100 * ($$l[$MYSQL_Innodb_buffer_pool_pages_dirty] 
            / $$l[$MYSQL_Innodb_buffer_pool_pages_data]))
		: 0;
	}
	show_val($pv,\@MYSQL_stats,$stat++,6);

	# Buff pool waits
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		 $MYSQL_Innodb_buffer_pool_wait_free );
	$stat += 1;

	# Data
	# Reads
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_data_reads );
	$stat++;
	# Read in bytes
	show_bytes_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_data_read );
	$stat++;

	# writes
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_data_writes );
	$stat++;
	show_bytes_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_data_written );
	$stat++;

	# fsyncs
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_data_fsyncs );
	$stat++;

	# Log
	# Writes
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_log_writes,$MYSQL_Innodb_os_log_fsyncs );
	$stat+=2;

	# Row
	# lock waits and time
	show_simple_avg(\@MYSQL_sum,$i,\@MYSQL_stats,$tsamples[$i],5,1,$stat,
		$MYSQL_Innodb_row_lock_waits,$MYSQL_Innodb_row_lock_time );
	$stat+=2;
    }
    if ($opt_nfsrops) {
	if ($os eq "freebsd") {
	    show_avg(6,$i,$tsamples[$i],1,\@NFS_sum,\@NFSROPS_stats,0,
		     $NFS_PROC_GETATTR,$NFS_PROC_LOOKUP,$NFS_PROC_ACCESS,
		     $NFS_PROC_READLINK,$NFS_PROC_READ,$NFS_PROC_READDIR,
		     $NFS_PROC_READDIRPLUS,$NFS_PROC_FSSTAT,$NFS_PROC_FSINFO,
		     $NFS_PROC_PATHCONF);
	} else {
	    my $stat = 0;

	    $NFS_sum[$NFS_PROC_GETATTR] = 0;
	    $NFS_sum[$NFS_PROC_LOOKUP] = 0;
	    $NFS_sum[$NFS_PROC_ACCESS] = 0;
	    $NFS_sum[$NFS_PROC_READLINK] = 0;
	    $NFS_sum[$NFS_PROC_READ] = 0;
	    $NFS_sum[$NFS_PROC_READDIR] = 0;
	    $NFS_sum[$NFS_PROC_READDIRPLUS] = 0;
	    $NFS_sum[$NFS_PROC_FSSTAT] = 0;
	    $NFS_sum[$NFS_PROC_FSINFO] = 0;
	    $NFS_sum[$NFS_PROC_PATHCONF] = 0;

	    for my $mount (keys %NFS_LX_sum) {
		my $nfs_mount = $NFS_LX_sum{$mount};
		$nfs_mount = $$nfs_mount[$i];
		$NFS_sum[$NFS_PROC_GETATTR] += $$nfs_mount[$NFS_LX_GATTR_OPS];
		$NFS_sum[$NFS_PROC_LOOKUP] += $$nfs_mount[$NFS_LX_LOOKUP_OPS];
		$NFS_sum[$NFS_PROC_ACCESS] += $$nfs_mount[$NFS_LX_ACCESS_OPS];
		$NFS_sum[$NFS_PROC_READLINK] += $$nfs_mount[$NFS_LX_RDLINK_OPS];
		$NFS_sum[$NFS_PROC_READ] += $$nfs_mount[$NFS_LX_READ_OPS];
		$NFS_sum[$NFS_PROC_READDIR] += $$nfs_mount[$NFS_LX_RDDIR_OPS];
		$NFS_sum[$NFS_PROC_READDIRPLUS] += $$nfs_mount[$NFS_LX_RDDIRPLUS_OPS];
		$NFS_sum[$NFS_PROC_FSSTAT] += $$nfs_mount[$NFS_LX_FSSTAT_OPS];
		$NFS_sum[$NFS_PROC_FSINFO] += $$nfs_mount[$NFS_LX_FSINFO_OPS];
		$NFS_sum[$NFS_PROC_PATHCONF] += $$nfs_mount[$NFS_LX_PCONF_OPS];
	    }

	    my $pv;
	    undef($pv);
	    if ($tsamples[$i] != 0) {
		$pv = $NFS_sum[$NFS_PROC_GETATTR]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_LOOKUP]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_ACCESS]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_READLINK]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_READ]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_READDIR]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_READDIRPLUS]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_FSSTAT]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_FSINFO]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_PATHCONF]/$tsamples[$i];
		show_val($pv,\@NFSROPS_stats,$stat++,6);
	    } else {
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
		show_val($pv,\@NFSROPS_stats,$stat++,6);
	    }
	}
    }
    if ($opt_nfswops) {
	if ($os eq "freebsd") {
	    show_avg(6,$i,$tsamples[$i],1,\@NFS_sum,\@NFSWOPS_stats,0,
		     $NFS_PROC_SETATTR,$NFS_PROC_WRITE,$NFS_PROC_CREATE,
		     $NFS_PROC_MKDIR,$NFS_PROC_SYMLINK,$NFS_PROC_MKNOD,
		     $NFS_PROC_REMOVE,$NFS_PROC_RMDIR,$NFS_PROC_RENAME,
		     $NFS_PROC_LINK);
	} else {
	    my $stat = 0;

	    $NFS_sum[$NFS_PROC_SETATTR] = 0;
	    $NFS_sum[$NFS_PROC_WRITE] = 0;
	    $NFS_sum[$NFS_PROC_CREATE] = 0;
	    $NFS_sum[$NFS_PROC_MKDIR] = 0;
	    $NFS_sum[$NFS_PROC_SYMLINK] = 0;
	    $NFS_sum[$NFS_PROC_MKNOD] = 0;
	    $NFS_sum[$NFS_PROC_REMOVE] = 0;
	    $NFS_sum[$NFS_PROC_RMDIR] = 0;
	    $NFS_sum[$NFS_PROC_RENAME] = 0;
	    $NFS_sum[$NFS_PROC_LINK] = 0;

	    for my $mount (keys %NFS_LX_sum) {
		my $nfs_mount = $NFS_LX_sum{$mount};
		$nfs_mount = $$nfs_mount[$i];
		$NFS_sum[$NFS_PROC_SETATTR] += $$nfs_mount[$NFS_LX_SATTR_OPS];
		$NFS_sum[$NFS_PROC_WRITE] += $$nfs_mount[$NFS_LX_WRITE_OPS];
		$NFS_sum[$NFS_PROC_CREATE] += $$nfs_mount[$NFS_LX_CREATE_OPS];
		$NFS_sum[$NFS_PROC_MKDIR] += $$nfs_mount[$NFS_LX_MKDIR_OPS];
		$NFS_sum[$NFS_PROC_SYMLINK] += $$nfs_mount[$NFS_LX_SYMLINK_OPS];
		$NFS_sum[$NFS_PROC_MKNOD] += $$nfs_mount[$NFS_LX_MKNODE_OPS];
		$NFS_sum[$NFS_PROC_REMOVE] += $$nfs_mount[$NFS_LX_REMOVE_OPS];
		$NFS_sum[$NFS_PROC_RMDIR] += $$nfs_mount[$NFS_LX_RMDIR_OPS];
		$NFS_sum[$NFS_PROC_RENAME] += $$nfs_mount[$NFS_LX_RENAME_OPS];
		$NFS_sum[$NFS_PROC_LINK] += $$nfs_mount[$NFS_LX_LINK_OPS];
	    }

	    my $pv;
	    undef($pv);
	    if ($tsamples[$i] != 0) {
		$pv = $NFS_sum[$NFS_PROC_SETATTR]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_WRITE]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_CREATE]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_MKDIR]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_SYMLINK]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_MKNOD]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_REMOVE]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_RMDIR]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_RENAME]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);

		$pv = $NFS_sum[$NFS_PROC_LINK]/$tsamples[$i];
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
	    } else {
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
		show_val($pv,\@NFSWOPS_stats,$stat++,6);
	    }
	}
    }
    if ($opt_nfscache) {
	my $stat = 0;
	show_ratio_1(7,$i,\@NFS_sum,\@NFSCACHE_stats,$stat,
		     $NFS_ATTRCACHE_HITS,$NFS_ATTRCACHE_MISSES,
		     $NFS_LOOKUPCACHE_HITS,$NFS_LOOKUPCACHE_MISSES,
		     $NFS_DIREOFCACHE_HITS,$NFS_DIREOFCACHE_MISSES);
	$stat += 3;
	show_ratio_2(7,$i,\@NFS_sum,\@NFSCACHE_stats,$stat,
		     $NFS_BIOCACHE_READS,$NFS_READ_BIOS,
		     $NFS_BIOCACHE_WRITES,$NFS_WRITE_BIOS,
		     $NFS_BIOCACHE_READLINKS,$NFS_READLINK_BIOS,
		     $NFS_BIOCACHE_READDIRS,$NFS_READDIR_BIOS);
	$stat += 4;
    }
    if ($opt_nfsopx) {
	my $nfs_mount = $NFS_LX_sum{$opt_nfsop_mount};
	if (defined($nfs_mount)) {
	    my $stat = 0;
	    $nfs_mount = $$nfs_mount[$i];
	    my ($c_ops, $c_kb, $c_retrans, $c_rtt, $c_exe) = nfs_op_status_counters();

	    my $pv = $tsamples[$i] ? $$nfs_mount[$c_ops] / $tsamples[$i] : 0;
	    show_val($pv,\@NFS_LX_stats,$stat++,9);

	    $pv = $tsamples[$i] ? $$nfs_mount[$c_kb] / $tsamples[$i] : 0;
	    show_val($pv,\@NFS_LX_stats,$stat++,9);

	    show_val($$nfs_mount[$c_retrans],\@NFS_LX_stats,$stat++,9);

	    $pv = $$nfs_mount[$c_ops] ? $$nfs_mount[$c_rtt] / $$nfs_mount[$c_ops] : 0;
	    show_val($pv,\@NFS_LX_stats,$stat++,9);

	    $pv = $$nfs_mount[$c_ops] ? $$nfs_mount[$c_exe] / $$nfs_mount[$c_ops] : 0;
	    show_val($pv,\@NFS_LX_stats,$stat++,9);
	}
    }
    if ($opt_ciss) {
	my $stat = 0;

	show_avg(7,$i,$tsamples[$i],[1,1],\@CISS_sum,\@CISS_stats,$stat,
		 $CISS_COMMANDS,$CISS_LOGICAL_REQUESTS);
	$stat += 2;
	show_ratio_3(7,undef,(128/100),\@CISS_sum,\@CISS_stats,$stat++,
		     $CISS_ACTIVE,$CISS_SAMPLE_INTERVAL);
	show_ratio_3(7,$i,(128/100),\@CISS_sum,\@CISS_stats,$stat++,
		     $CISS_COMMAND_LATENCY,$CISS_COMMANDS);
	if (@CISS1_sum > 0) {
	    show_avg(7,$i,$tsamples[$i],[1,1,1000],\@CISS1_sum,\@CISS_stats,$stat,
		     $CISS_COMMANDS,$CISS_LOGICAL_REQUESTS,$CISS_ACTIVE);
	    $stat += 3;
	    show_ratio_3(7,$i,(128/100),\@CISS1_sum,\@CISS_stats,$stat++,
			 $CISS_COMMAND_LATENCY,$CISS_COMMANDS);
	}
	for my $v (sort keys %CISS_sum) {
	    $stat = 0;
	    if (!defined($CISS_stats{$v})) {
		$CISS_stats{$v} = [];
	    }
	    my $cs = $CISS_stats{$v};
	    my $vs = $CISS_sum{$v};
	    show_avg_w($i,$tsamples[$i],[1,2],$vs,$cs,$stat,
		       $CISS_LOGICAL_READS,7,
		       $CISS_SECTORS_READ,9);
	    $stat += 2;
	    show_ratio(7,$i,$vs,$cs,$stat++,$CISS_NON_SEQ_READS,$CISS_LOGICAL_READS);
	    show_ratio_3(7,$i,(128/100),$vs,$cs,$stat++,$CISS_READ_LATENCY,$CISS_LOGICAL_READS);
	    show_avg_w($i,$tsamples[$i],[1,2],$vs,$cs,$stat,
		       $CISS_LOGICAL_WRITES,7,
		       $CISS_SECTORS_WRITTEN,9);
	    $stat += 2;
	    show_ratio(7,$i,$vs,$cs,$stat++,$CISS_NON_SEQ_WRITES,$CISS_LOGICAL_WRITES);
	    show_ratio_3(7,$i,(128/100),$vs,$cs,$stat++,$CISS_WRITE_LATENCY,$CISS_LOGICAL_WRITES);
	    show_ratio_1(7,$i,$vs,$cs,$stat++,$CISS_CACHE_MISSES,$CISS_CACHE_HITS);
	    show_ratio(7,$i,$vs,$cs,$stat,
		       $CISS_UNALIGNED_READS,$CISS_LOGICAL_READS,
		       $CISS_UNALIGNED_WRITES,$CISS_LOGICAL_WRITES);
	    $stat += 2;

	    my $drsum = 0;
	    my $drmax = 0;
	    my $dwsum = 0;
	    my $dwmax = 0;
	    my $dnum = 0;
	    my $ds = $CISSD_sum{"cissd.".substr($v,5)};
	    if ($ds && $$ds[$i]) {
		my $d = $$ds[$i];
		for (my $i = 0; $i < @$d; $i += 2) {
		    $dnum++;
		    $drsum += $$d[$i];
		    if ($$d[$i] > $drmax) {
			$drmax = $$d[$i];
		    }
		    $dwsum += $$d[$i+1];
		    if ($$d[$i+1] > $dwmax) {
			$dwmax = $$d[$i+1];
		    }
		}
	    }
	    $drmax *= $dnum;
	    $dwmax *= $dnum;
	    show_avg_w($i,$tsamples[$i],1,$vs,$cs,$stat++,$CISS_READ_REQUESTS,8);
	    show_avg(7,0,$dnum*$tsamples[$i],1,[[$drsum,$drmax]],$cs,$stat,0,1);
	    $stat += 2;
	    show_avg_w($i,$tsamples[$i],1,$vs,$cs,$stat++,$CISS_WRITE_REQUESTS,8);
	    show_avg(7,0,$dnum*$tsamples[$i],1,[[$dwsum,$dwmax]],$cs,$stat,0,1);
	    $stat += 2;
	}
    }
    if ($opt_kmem) {
	my $stat = 0;
	show_ratio(7,$i,\@KMEM_sum,\@KMEM_stats,$stat,
		   $KMEM_MBUF_USED,$KMEM_MBUF_MAX,
		   $KMEM_MBUFC_USED,$KMEM_MBUFC_MAX);
	$stat += 2;
	show_intvals(7,$i,$samples[$i],\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_SOCK_USED);
	show_ratio(7,$i,\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_SOCK_USED,$KMEM_SOCK_MAX);
	show_intvals(10,$i,$samples[$i],\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_PVENTRY_USED);
	show_ratio(7,$i,\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_PVENTRY_USED,$KMEM_PVENTRY_MAX);
	show_avg(7,$i,$samples[$i],(1024*1024),\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_KVM);
	show_ratio(7,$i,\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_KVM,$KMEM_KVM_MAX);
	show_intvals(8,$i,$samples[$i],\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_FILES);
	show_ratio(7,$i,\@KMEM_sum,\@KMEM_stats,$stat++,$KMEM_FILES,$KMEM_FILES_MAX);
    }
    if ($opt_tcpx) {
	my $stat = 0;
	show_avg_w($i,$samples[$i],[1000,1000,1,1,1,1,1,1],
		   \@TCP_sum,\@TCPX_stats,0,
		   $TCP_RECVQ,8,
		   $TCP_SENDQ,8,
		   $TCP_EST,8,
		   $TCP_TIME_WAIT,6,
		   $TCP_FIN_WAIT_1,6,
		   $TCP_FIN_WAIT_2,6,
		   $TCP_LISTENQ,6,
		   $TCP_LISTENINCQ,6);
	$stat += 8;
	show_avg_w($i,$tsamples[$i],1,
		   \@TCP1_sum,\@TCPX_stats,$stat,
		   $TCP_LISTENOVER,7,
		   $TCP_NCONNEST,8,
		   $TCP_NCONNDROP,6);
	$stat += 3;
	show_avg_w($i,$tsamples[$i],-1,
		   \@TCP1_sum,\@TCPX_stats,$stat,
		   $TCP_EMBDROP,6,
		   $TCP_REXMITDROP,6,
		   $TCP_PERSISTDROP,6,
		   $TCP_KADROP,6);
	$stat += 4;
    }
    if ($opt_ynodejs) {
	show_avg(8,$i,$samples[$i],1,\@YNODEJS_sum,\@YNODEJS_stats,0,
		 $YNODEJS_REQUESTS,$YNODEJS_LATENCY,$YNODEJS_KBIN,$YNODEJS_KBOUT,$YNODEJS_AVGCONC,$YNODEJS_MAXCONC);
    }
    if ($opt_shmproxy_que or $opt_shmproxy_drops or $opt_shmproxy_ci or $opt_shmproxy_co
       or $opt_shmproxy_pi or $opt_shmproxy_po or $opt_shmproxy_rd ) {
	for my $port ( sort keys %SHMP_prev  ){
	    my $stat = 0;
	    
	    if (not defined $SHMP_stats{$port}){
		$SHMP_stats{$port} = [];
	    }
	    
	    if ($opt_shmproxy_que ){
		show_intvals(8,$i,$tsamples[$i],$SHMP_sum{$port},$SHMP_stats{$port}  , $stat, $SHMP_CCURQUEMSG, $SHMP_CTOTQUEMSG, $SHMP_PTOTQUEMSG);
		$stat += 3;
	    }
	    
	    if ($opt_shmproxy_ci){
		show_avg(8,$i,$tsamples[$i],1,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_CINMSG );
		show_avg(8,$i,$tsamples[$i],1024,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_CINBYTE );
		show_ratio_r_noperc(8, $i , $SHMP_sum{$port},$SHMP_stats{$port}, $stat++ ,
				    $SHMP_CINBYTE , $SHMP_CINMSG , 1 , );
	    }
	    
	    if ($opt_shmproxy_co){
		show_avg(8,$i,$tsamples[$i],1,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_COUTMSG );
		show_avg(8,$i,$tsamples[$i],1024,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_COUTBYTE );
		show_ratio_r_noperc(8, $i , $SHMP_sum{$port},$SHMP_stats{$port}, $stat++ ,
				    $SHMP_COUTBYTE , $SHMP_COUTMSG , 1 , );
	    }

	    if ($opt_shmproxy_pi){
		show_avg(8,$i,$tsamples[$i],1,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_PINMSG );
		show_avg(8,$i,$tsamples[$i],1024,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_PINBYTE );
		show_ratio_r_noperc(8, $i , $SHMP_sum{$port},$SHMP_stats{$port}, $stat++ ,
				    $SHMP_PINBYTE , $SHMP_PINMSG , 1 , );
	    }
	    
	    if ($opt_shmproxy_po){
		show_avg(8,$i,$tsamples[$i],1,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_POUTMSG );
		show_avg(8,$i,$tsamples[$i],1024,$SHMP_sum{$port},$SHMP_stats{$port},$stat++,$SHMP_POUTBYTE );
		show_ratio_r_noperc(8, $i , $SHMP_sum{$port},$SHMP_stats{$port}, $stat++ ,
				    $SHMP_POUTBYTE , $SHMP_POUTMSG , 1 , );
	    }
	    
	    if ($opt_shmproxy_rd){
		show_avg_w_r($i,$tsamples[$i],1,$SHMP_sum{$port},$SHMP_stats{$port},$stat,
			     $SHMP_CDROPMSG, 8, 3,  $SHMP_CDROPBYTE, 8, 1,
			     $SHMP_PDROPMSG, 8, 3,  $SHMP_PDROPBYTE, 8, 1, );
		$stat+=2;
	    }
	    
	    #  about 4 numbers is all we can get out of an ES... cuz they have lots of shmproxy stuff.
	    if ($opt_shmproxy_drops){
		show_ratio_r_noperc(8,$i,$SHMP_sum{$port},$SHMP_stats{$port},$stat,
				    $SHMP_CDROPMSG , $SHMP_CINMSG , 3 ,
				    $SHMP_CDROPMSG , $SHMP_COUTMSG , 3 ,
				    $SHMP_PDROPMSG , $SHMP_PINMSG , 3,
				    $SHMP_PDROPMSG , $SHMP_POUTMSG , 3,
		    );
		$stat += 4;
	    }
	}
    }
    
    eval $plugins{'columns'};
    if (!$opt_Max) {
	$outbuf .= "\n";
	if ($outstats > 0) {
	    if ($hdrbuf) {
		print OUT $hdrbuf;
		$hdrbuf = '';
	    }
	    print OUT $outbuf;
	    $outlines++;
	}
    }
}

my @STAT_NAMES = ("","Mean        ","Min         ","Max         ",
		  "","",
		  "","Max req/sec ","Max rt      ","Max cpu     ","Max mem     ");
my @STATS = ($STAT_MIN,$STAT_SAMPLES,$STAT_MAX);

if ($opt_Max) {
    $outbuf = "";
    print_header();
    print OUT $outbuf;
    for (my $i = 0; $i < @SUMMARY_stats; $i++) {
	my $stat = $SUMMARY_stats[$i];
	$outbuf = strftime("%m/%d-%H:%M  ",localtime($$stat[$STAT_MAXTIME]));
	for (my $j = 0; $j < @SUMMARY_stats; $j++) {
	    my $s = $SUMMARY_stats[$j];
	    if (defined($$s[$i + $STAT_MAXBASE])) {
		$outbuf .= sprintf("%*.1f%s",
				   $$s[$STAT_WIDTH]-1,
				   $$s[$i + $STAT_MAXBASE],
				   ($j == $i) ? "*" : " ");
	    } else {
		$outbuf .= sprintf("%*s ",$$s[$STAT_WIDTH]-1,"-");
	    }
	}
	print $outbuf."\n";
    }
} elsif (!$opt_raw && !$opt_current) {
    print OUT "\n";
    for my $i (@STATS) {
	$outbuf = $STAT_NAMES[$i];
	if ($opt_summary) {
	    show_stats($i,\@SUMMARY_stats);
	}
	if ($opt_util) {
	    show_stats($i,\@UTIL_stats);
	}
	if ($opt_apache) {
	    show_stats($i,\@YAP_stats);
	}
	if ($opt_yts) {
            show_stats($i,\@YTS_stats);
	}
	if ($opt_ytscache) {
            show_stats($i,\@YTSCACHE_stats);
	}
	if ($opt_ytserr) {
            show_stats($i,\@YTSERR_stats);
	}
	if ($opt_ytstls) {
	    show_stats($i,\@YTSTLS_stats);
	}
	if ($opt_cpushare) {
	    show_stats($i,\@CPUT_stats);
	}
	if ($opt_mem) {
	    show_stats($i,\@MEM_stats);
	}
	if ($opt_memx) {
	    show_stats($i,\@MEMX_stats);
	}
	if ($opt_load) {
	    show_stats($i,\@LD_stats);
	}
	if ($opt_ps) {
	    show_stats($i,\@PS_stats);
	}
	if ($opt_sys) {
	    show_stats($i,\@SYS_stats);
	}
	if ($opt_swap) {
	    show_stats($i,\@SWAP_stats);
	}
	if ($opt_fork) {
	    show_stats($i,\@FORK_stats);
	}
	if ($opt_tcp) {
	    show_stats($i,\@TCP_stats);
	}
	if ($opt_udp) {
	    show_stats($i,\@UDP_stats);
	}
	if ($opt_ip) {
	    show_stats($i,\@IP_stats);
	}
	if ($opt_devstat) {
	    for my $dev (sort keys %DS_sum) {
		show_stats($i,$DS_stats{$dev});
	    }
	}
	if ($opt_if) {
	    for my $if (keys %IF_sum) {
		show_stats($i,$IF_stats{$if});
	    }
	}
	if ($opt_df) {
	    for my $df (keys %DF_sum) {
		show_stats($i,$DF_stats{$df});
	    }
	}
	if ($opt_mysql) {
	    show_mysql_stats($i,\@MYSQL_stats);
	}
        if ($opt_ysquid) {
            show_ysquid_stats($i,\@YSQUID_stats);
        }
	if ($opt_ysquidhealth) {
	    show_ysquidhealth_stats($i,\@YSQUIDHEALTH_stats);
	}
	if ($opt_innodb) {
	    show_innodb_stats($i,\@MYSQL_stats);
	}
	if ($opt_nfsrops) {
	    show_stats($i,\@NFSROPS_stats);
	}
	if ($opt_nfswops) {
	    show_stats($i,\@NFSWOPS_stats);
	}
	if ($opt_nfscache) {
	    show_stats($i,\@NFSCACHE_stats);
	}
	if ($opt_nfsopx) {
	    show_stats($i,\@NFS_LX_stats);
	}
	if ($opt_ciss) {
	    show_stats($i,\@CISS_stats);
	    for my $ciss (keys %CISS_stats) {
		show_stats($i,$CISS_stats{$ciss});
	    }
	}
	if ($opt_kmem) {
	    show_stats($i,\@KMEM_stats);
	}
	if ($opt_tcpx) {
	    show_stats($i,\@TCPX_stats);
	}
        if ($opt_shmproxy_que or $opt_shmproxy_drops or $opt_shmproxy_ci or $opt_shmproxy_co
            or $opt_shmproxy_pi or $opt_shmproxy_po or $opt_shmproxy_rd ){
             for my $port (sort keys %SHMP_sum){
                 show_stats($i,$SHMP_stats{$port});
             }
        }
	if ($opt_ynodejs) {
	    show_stats($i,\@YNODEJS_stats);
	}
        eval $plugins{'show_stats'};
	$outbuf .= "\n";
	print OUT $outbuf;
    }

}

if ($cgi) {
    if (!$opt_raw) {
	print OUT "</pre>\n";
	print OUT $cgi->end_html;
    }
}



sub print_header {
    if (!$opt_raw) {
	$outbuf .=  "            ";
	if ($opt_summary) {
	    $outbuf .=  " apache   rt    cpu   mem  swap   sysc swtch";
	    for my $dev (sort keys %DS_sum) {
		$outbuf .= sprintf(" %5s",$dev);
	    }
	    for my $df (sort keys %DF_sum) {
		$outbuf .= sprintf(" %5s",substr($df,2));
	    }
	    for my $if (keys %IF_sum) {
		$outbuf .= sprintf("      %-10s",substr($if,3));
	    }
	}
	if ($opt_util) {
	    $outbuf .= "   cpu   mem";
	    for my $dev (sort keys %DS_sum) {
		$outbuf .= sprintf(" %5s",$dev);
	    }
	    for my $df (sort keys %DF_sum) {
		$outbuf .= sprintf(" %5s",substr($df,2));
	    }
	    for my $if (keys %IF_sum) {
		$outbuf .= sprintf("  %-10s",substr($if,3)."-%util");
	    }
	    $outbuf .= " cpueff";
	}
	if ($opt_apache) {
	    $outbuf .=  "| apache  ------ avg per req ------  max";
	}
	if ($opt_yts) {
	    $outbuf .=  "| YTS       Client traffic       avg resp         Origin traffic        ";
	}
	if ($opt_ytscache) {
	    $outbuf .=  "| YTS Cache           conns   resp time(ms)     errors   ";
	}
	if ($opt_ytserr) {
	    $outbuf .=  "| YTS Errors                                  ";
	}
	if ($opt_ytstls) {
	    $outbuf .=  "| YTS TLS Errors (user agent connection)                               ";
	}
	if ($opt_cpushare) {
	    $outbuf .=  "| CPU Share (%)               ";
	}
	if ($opt_mem) {
	    $outbuf .=  "| Physical Memory (MB)                       ";
	}
	if ($opt_memx) {
	    $outbuf .=  "| Physical Memory (MB) - Extended                                                ";
	}
	if ($opt_load) {
	    $outbuf .=  "| Load        ";
	}
	if ($opt_ps) {
	    $outbuf .=  "| Process States        ";
	}
	if ($opt_sys) {
	    $outbuf .=  "| OS Activity (k/sec)";
	}
	if ($opt_swap) {
	    $outbuf .=  "| Swap (pgs/s)              ";
	}
	if ($opt_fork) {
	    $outbuf .=  "| Fork (/sec) ";
	}
	if ($opt_tcp) {
	    $outbuf .=  "| TCP (k/sec)                                 syncache           ";
	}
	if ($opt_udp) {
	    $outbuf .=  "| UDP (k/sec)        ";
	}
	if ($opt_ip) {
	    $outbuf .=  "| IP (k/sec)  ";
	}
	if ($opt_devstat) {
	    for my $dev (sort keys %DS_sum) {
		if ($os eq "rhel") {
		    $outbuf .= sprintf("| Device %-50s",$dev." (/sec)");
		} else {
		    $outbuf .= sprintf("| Device %-29s",$dev." (/sec)");
		}
	    }
	}
	if ($opt_if) {
	    for my $if (keys %IF_sum) {
		$outbuf .= sprintf("| Network if_%-36s",substr($if,3)." (k/sec)");
	    }
	}
	if ($opt_df) {
	    for my $df (keys %DF_sum) {
		$outbuf .= sprintf("| %9s",substr($df,2));
	    }
	}
	if ($opt_mysql) {
	    $outbuf .= "| MySQL           kb/sec          commands/sec              num   threads    kbuf locks q-cache      repl";
	}
        if ($opt_ysquid) {
	    # include the top line only if ysquid option is requested otherwise ysar
	    # does not support 3 line headers and this causes all display to get messed up
	    if (only_ysquid_requested()) {
		$outbuf .= "|            -- svc time (ms) --  ----- result type as % of total reqs ------\n";
		$outbuf .= "            |  ysquid     average    median   --------- hit --------- ------- miss ------";
	    } else {
		$outbuf .= "|  ysquid     average    median   --------- hit --------- ------- miss ------";
	    }
        }
	if ($opt_ysquidhealth) {
            $outbuf .= "           ------ size ----- --- fds ---  page  http   icp   icp";
	}
	if ($opt_innodb) {
	    $outbuf .= "| Innodb Engine       Buffer Pool                        Data                     Log       Lock";
	}
	if ($opt_nfsrops) {
	    $outbuf .= "| NFS read ops/sec                                          ";
	}
	if ($opt_nfswops) {
	    $outbuf .= "| NFS write ops/sec                                         ";
	}
	if ($opt_nfscache) {
	    $outbuf .= "| NFS cache hit%                        ";
	}
	if ($opt_nfsopx) {
	    $outbuf .= sprintf("| NFS Op: %5.5s Mount: %-22.22s",$opt_nfsop_op,$opt_nfsop_mount);
	}
	if ($opt_ciss) {
	    $outbuf .= "| CISS controller 0      lat";
	    if (@CISS1_sum > 0) {
		$outbuf .= "| CISS controller 1      lat";
	    }
	    for my $if (sort keys %CISS_sum) {
		$outbuf .= sprintf("| CISS %-4s              r-lat                         w-lat  cache    unaligned     drive i/o                               ",
				   substr($if,5));
	    }
	}
	if ($opt_kmem) {
	    $outbuf .= "|Kernel mem      sockets          pv entries      kvm          files      ";
	}
	if ($opt_tcpx) {
	    $outbuf .=
		"|TCPrcvq   sendq     tcp  time   fin   fin listn listn listen    nest ndrop-->emb rexmt perst keepa";
	}
	if ($opt_ynodejs) {
	    $outbuf .=  "| YNode JS        ";
	}
	
        if ($opt_shmproxy_que or $opt_shmproxy_drops or $opt_shmproxy_ci or $opt_shmproxy_co
	    or $opt_shmproxy_pi or $opt_shmproxy_po or $opt_shmproxy_rd ){
	    for my $port ( sort keys %SHMP_sum) {
		my $portnum='unknown';
		if ($port =~ /^shmproxy\.(.+)/){
		    $portnum = $1;
		}
                if ($opt_shmproxy_que ) {
		    $outbuf .= sprintf("| shmp cmdport %8s ", $portnum);
                }
		if ($opt_shmproxy_ci) {
		    $outbuf .=  sprintf("| shmp cmdport %9s",$portnum);
		}
		if ($opt_shmproxy_co) {
		    $outbuf .=  sprintf("| shmp cmdport %9s",$portnum);
		}
		if ($opt_shmproxy_pi) {
		    $outbuf .=  sprintf("| shmp cmdport %9s",$portnum);
		}
		if ($opt_shmproxy_po) {
		    $outbuf .=  sprintf("| shmp cmdport %9s",$portnum);
		}
		if ($opt_shmproxy_drops) {
		    $outbuf  .= sprintf("|shmp cmdp %8s (%%) drop    ", $portnum);
		}
		if ($opt_shmproxy_rd) {
		    $outbuf  .= sprintf("| shmp cmdp %8s drop cnt/s ", $portnum);
		}
	    }
	}
	
        eval $plugins{'header1'};
	$outbuf .=  "\n";
    }
    $outbuf .=  "Time        ";
    if ($opt_summary) {
	if ($opt_raw) {
	    $outbuf .=  " req/s     rt    cpu   mem  swap  sysc swtch";
	    for my $dev (sort keys %DS_sum) {
		$outbuf .= sprintf("%6s",$dev);
	    }
	    for my $df (sort keys %DF_sum) {
		$outbuf .= sprintf("%6s",substr($df,2));
	    }
	    for my $if (keys %IF_sum) {
		$outbuf .= sprintf("%8s%8s",substr($if,3)."in",substr($if,3)."out");
	    }
	} else {
	    $outbuf .=  " req/s    msec %util %util  %pgs   /pkt  /pkt";
	    for my $dev (sort keys %DS_sum) {
		$outbuf .=  " %busy";
	    }
	    for my $df (sort keys %DF_sum) {
		$outbuf .=  " %full";
	    }
	    for my $if (keys %IF_sum) {
		$outbuf .=  " in-kbps outkbps";
	    }
	}
    }
    if ($opt_util) {
	$outbuf .=  " %util %util";
	for my $dev (sort keys %DS_sum) {
	    $outbuf .=  " %busy";
	}
	for my $df (sort keys %DF_sum) {
	    $outbuf .=  " %full";
	}
	for my $if (keys %IF_sum) {
	    $outbuf .=  "    in   out";
	}
	$outbuf .= " kb/MHz";
    }
    if ($opt_apache) {
	$outbuf .=  " req/s     msec   kbin  kbout  conc  conc";
    }
    if ($opt_yts) {
        $outbuf .=  "   req/s    cons req/con    mbps      ms     req/s    cons req/con    mbps";
    }
    if ($opt_ytscache) {
        $outbuf .=  "   overall      ram  active     hit    miss   read  write";
    }
    if ($opt_ytserr) {
        $outbuf .=  "  no Host:   abort  hangup  conn-fail   other";
    }
    if ($opt_ytstls) {
        $outbuf .=  "   other expired revoked unknown  verify badcert decrypt version unkwnCA";
    }
    if ($opt_cpushare) {
	$outbuf .=  "  user  nice   sys  intr  idle";
	if ($os eq "rhel") {
	    $outbuf .=  " iowait";
	}
    }
    if ($opt_mem) {
	$outbuf .=  "   active    inact   cached     free    wired";
    }
    if ($opt_memx) {
	$outbuf .=  "  buffers   cached   sw_tot  sw_free   hp_tot  hp_free  hp_rsvd  hp_surp  hp_size";
    }
    if ($opt_load) {
	$outbuf .=  "   1M    5M    15M";
    }
    if ($opt_ps) {
	$outbuf .=  "   run sleep  idle  disk";
    }
    if ($opt_sys) {
	$outbuf .=  " cswtch   sysc   intr";
    }
    if ($opt_swap) {
	$outbuf .=  "    out  vnode     in  vnode";
    }
    if ($opt_fork) {
	$outbuf .=  "  fork vfork";
    }
    if ($opt_tcp) {
	$outbuf .=  "  rxpkts   bytes  txpkts   bytes %retx bytes  added ovrflw bktovr";
    }
    if ($opt_udp) {
	$outbuf .=  " rxpkts txpkts  %drop";
    }
    if ($opt_ip) {
	$outbuf .=  " rxpkts txpkts";
    }
    if ($opt_devstat) {
	for my $dev (sort keys %DS_sum) {
	    $outbuf .=  "  reads   kbread writes  kbwrite %busy";
	    if ($os eq "rhel") {
		$outbuf .=  "  avgqu  await  svctm";
	    }
	}
    }
    if ($opt_if) {
	for my $if (keys %IF_sum) {
	    $outbuf .=  " rxpkts  bytes txpkts  bytes  ierrs  oerrs  colls";
	}
    }
    if ($opt_df) {
	for my $df (keys %DF_sum) {
	    $outbuf .= "      %used";
	}
    }
    if ($opt_mysql) {
	$outbuf .= "  nconn   numq    recv    sent    sel    ins    upd    del slow   tot   run %miss %wait %miss %full delay";
    }
    if ($opt_ysquid) {
        $outbuf .= " req/s hit%  hit miss   hit miss  mem disk  ims stal asyn full  ref cref asyn";
    }
    if ($opt_ysquidhealth) {
        $outbuf .= " req/s hit%  proc   mem  disk  used  disk fault out/s out/s  in/s";
    }
    if ($opt_innodb) {
	$outbuf .= " read  ins  upd  del  new read %phy wrte %phy %dirt wait read      wrte      fsyc wrte fsyc wait time";
    }
    if ($opt_nfsrops) {
	$outbuf .= " gattr  lkup acces rdlnk  read rddir rdir+ fssta fsinf pconf";
    }
    if ($opt_nfswops) {
	$outbuf .= " sattr write creat mkdir sylnk mknod remov rmdir renam  link";
    }
    if ($opt_nfscache) {
	$outbuf .= "   attr lookup  direof  read  write rdlink  rddir";
    }
    if ($opt_nfsopx) {
	$outbuf .= "    ops/s     kb/s  retrans   rtt/op   exe/op";
    }
    if ($opt_ciss) {
	$outbuf .= "   cmds   reqs  busy%   msec";
	if (@CISS1_sum > 0) {
	    $outbuf .= "   cmds   reqs  busy%   msec";	    
	}
	for my $if (sort keys %CISS_sum) {
	    $outbuf .= "  reads   kbread  rand%   msec writes  kbwrite  rand%   msec  miss%    rd%    wr%    rsum   ravg   rmax    wsum   wavg   wmax";
	}
    }
    if ($opt_kmem) {
	$outbuf .= "  mbuf%  mbcl%   used      %      used      %     mb      %    open      %";
    }
    if ($opt_tcpx) {
	$outbuf .= "      kb      kb     est  wait wait1 wait2  qlen  incq ovflws    /sec  /sec  /sec  /sec  /sec  /sec";
    }
    if ($opt_ynodejs) {
	$outbuf .=  "   req/s  latency   kbin/s  kbout/s  conc  concmax";
    }
    if ($opt_shmproxy_que or $opt_shmproxy_drops or $opt_shmproxy_ci or $opt_shmproxy_co
	or $opt_shmproxy_pi or $opt_shmproxy_po or $opt_shmproxy_rd ){
	for my $port ( sort keys %SHMP_sum) {
	    if ($opt_shmproxy_que) {
               $outbuf .= "  cCurQM  cTotQM  pTotQM";
            }
	    if ($opt_shmproxy_drops) {
		$outbuf  .= "   cd/in  cd/out   pd/in  pd/out";
            }
	    if ($opt_shmproxy_ci) {
		$outbuf .= "  cInMsg cIn(KB)   B/Msg";
            }
	    if ($opt_shmproxy_co) {
		$outbuf .= " cOutMsg cOut(KB)  B/Msg";
	    }
	    if ($opt_shmproxy_pi) {
		$outbuf .= "  pInMsg pIn(KB)   B/Msg";
            }
	    if ($opt_shmproxy_po) {
		$outbuf .= " pOutMsg pOut(KB)  B/Msg";
	    }
            if ($opt_shmproxy_rd) {
		$outbuf .= "    cMsg  cBytes    pMsg  pBytes";
	    }
        }
    }
    eval $plugins{'header2'};
    $outbuf .=  "\n";
}

sub delta {
    my($new,$old) = @_;
    for (my $i = 0; $i < @$new; $i++) {
	my $newval;
	if ($i < @$old) {
	    if ($$new[$i] >= $$old[$i]) {
		$newval = $$new[$i] - $$old[$i];
	    } else {
		if ($cur_t >= $reboot_t && $prev_t < $reboot_t) {
		    $newval = $$new[$i];
		} else {
		    $newval = (4294967296 - $$old[$i]) + $$new[$i];
		}
	    }
	} else {
	    $newval = 0;
	}
	$$old[$i] = $$new[$i];
	$$new[$i] = $newval;
    }
}


sub lldelta {
    my($new,$old,$scale,$delta) = @_;
    for (my $i = 0; $i < @$new/2; $i++) {
	my $newval_h;
	my $newval_l;
	my $s = ref($scale) ? $$scale[$i] : $scale;
	my $val;
	if ($i < @$old/2
	    && ($$new[$i*2] > $$old[$i*2]
		|| ($$new[$i*2] == $$old[$i*2] && $$new[$i*2+1] > $$old[$i*2+1])))
	{
	    $val = $s*($$new[$i*2] - $$old[$i*2]) + $$new[$i*2+1] - $$old[$i*2+1];
	} else {
	    $val = 0;
	}

	$$delta[$i] = $val;
	$$old[$i*2] = $$new[$i*2];
	$$old[$i*2+1] = $$new[$i*2+1];
    }
}


sub add {
    my($index,$new,$sum) = @_;
    my $l = $$sum[$index];
    if (!$l) {
	$l = $$sum[$index] = [];
    }
    for (my $i = 0; $i < @$new; $i++) {
	if (defined($$new[$i])) {
	    if ($i >= @$l) {
		$$l[$i] = 0;
	    }
	    $$l[$i] += $$new[$i];
	}
    }
}


sub max {
    my($index,$new,$max) = @_;
    my $l = $$max[$index];
    if (!$l) {
	$l = $$max[$index] = [];
    }
    for (my $i = 0; $i < @$new; $i++) {
	if ($i < @$l) {
	    if ($$new[$i] > $$l[$i]) {
		$$l[$i] = $$new[$i];
	    }
	} else {
	    $$l[$i] = $$new[$i];
	}
    }
}

sub show_pct {
    my($pv,$stats,$stat,$width) = @_;
    if (defined($pv)) {
	$outbuf .= sprintf(" %*d",$width-1,$pv);
	$outstats++;
    } else {
	$outbuf .= sprintf(" %*s",$width-1,"-");
    }
    add_stats($stat,$stats,$pv,$width);
}

sub show_val {
    my($pv,$stats,$stat,$width) = @_;
    if (defined($pv)) {
	$outbuf .= sprintf(" %*.1f",$width-1,$pv);
	$outstats++;
    } else {
	$outbuf .= sprintf(" %*s",$width-1,"-");
    }
    add_stats($stat,$stats,$pv,$width);
}


sub show_val2 {
    my($pv,$stats,$stat,$width) = @_;
    if (defined($pv)) {
	$outbuf .= sprintf(" %*.2f",$width-1,$pv);
	$outstats++;
    } else {
	$outbuf .= sprintf(" %*s",$width-1,"-");
    }
    add_stats($stat,$stats,$pv,$width);
}


sub show_intval {
    my($pv,$stats,$stat,$width) = @_;
    if (defined($pv)) {
	$outbuf .= sprintf(" %*d",$width-1,$pv);
	$outstats++;
    } else {
	$outbuf .= sprintf(" %*s",$width-1,"-");
    }
    add_stats($stat,$stats,$pv,$width);
}

sub show_pluginval {
    my($pv,$stats,$stat,$width,$fp) = @_;
    if (defined($pv)) {
	$outbuf .= sprintf(" %*.${fp}f",$width-1,$pv);
	$outstats++;
    } else {
	$outbuf .= sprintf(" %*s",$width-1,"-");
    }
    add_stats($stat,$stats,$pv,$width);
}

sub show_intvals {
    my($width,$index,$nsamples,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
	my $v = shift(@which);
	my $pv;
	if ($l && $nsamples && $v < @$l) {
	    $pv = $$l[$v] / $nsamples;
	    $outbuf .= sprintf(" %*d",$width-1,$pv);
	    $outstats++;
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}


sub show_share {
    my($index,$val,$stats,$stat) = @_;
    my $l = $$val[$index];
    my $sum = 0;
    if ($l) {
	for my $v (@$l) {
	    $sum += $v;
	}
	my $j = 0;
	for my $v (@$l) {
	    my $pv = $sum ? $v/$sum*100 : 0;
	    $outbuf .= sprintf(" %5.1f",$pv);
	    add_stats($j+$stat,$stats,$pv,6);
	    $j++;
	    $outstats++;
	}
    }
}

sub format_number {
    my( $num, $sig, $max_len, $debug ) = @_;

    return 0 if( $num <= 0 );

    my $format = "%." . $sig . "f";

    my $raw_kilo = $num / 1000;
    my $raw_mega = $raw_kilo / 1000;
    my $raw_giga = $raw_mega / 1000;

    my $kilo = sprintf( $format, $raw_kilo );
    my $mega = sprintf( $format, $raw_mega );
    my $giga = sprintf( $format, $raw_giga );
    my $one = sprintf( $format, $num );

    print "$giga, $mega, $kilo, $one\n" if( $debug );

    if( $raw_giga >= 1 ) {
        if( length( $giga ) < $max_len ) {
            return $giga . 'g';
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $giga . 'g';
        }
    } elsif( $raw_mega >= 1 ) {
        if( length( $mega ) < $max_len ) {
            return $mega . 'm';
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $mega . 'm';
        }
    } elsif( $raw_kilo >= 1 ) {
        if( length( $kilo ) < $max_len ) {
            return $kilo . 'k';
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $kilo . 'k';
        }
    } else {
        if( length( $one ) <= $max_len ) {
            return $one;
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $one;
        }
    }
}

sub format_number_2 {
    my( $num, $sig, $max_len, $debug ) = @_;

    return 0 if( $num <= 0 );

    my ($int,$frac) = split(/\./, $num);
    if (length($int) >= 4) {
      $sig++;
    }

    my $format = "%." . $sig . "f";

    my $raw_kilo = $num / 1000;
    my $raw_mega = $raw_kilo / 1000;
    my $raw_giga = $raw_mega / 1000;

    my $kilo = sprintf( $format, $raw_kilo );
    my $mega = sprintf( $format, $raw_mega );
    my $giga = sprintf( $format, $raw_giga );
    my $one = sprintf( $format, $num );

    print "$giga, $mega, $kilo, $one\n" if( $debug );

    if( $raw_giga >= 1 ) {
        if( length( $giga ) < $max_len ) {
            return $giga . 'g';
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $giga . 'g';
        }
    } elsif( $raw_mega >= 1 ) {
        if( length( $mega ) < $max_len ) {
            return $mega . 'm';
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $mega . 'm';
        }
    } elsif( $raw_kilo >= 1 ) {
        if( length( $kilo ) < $max_len ) {
            return $kilo . 'k';
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $kilo . 'k';
        }
    } else {
        if( length( $one ) <= $max_len ) {
            return $one;
        } else {
            $sig > 0 ?
                return &format_number( $num, $sig - 1, $max_len, $debug ) :
                return $one;
        }
    }
}

sub format_memory {
    my( $num, $sig, $max_len, $debug ) = @_;

    return 0 if( $num <= 0 );

    my $format = "%." . $sig . "f";

    my $raw_kilo = $num / 1024;
    my $raw_mega = $raw_kilo / 1024;
    my $raw_giga = $raw_mega / 1024;

    my $kilo = sprintf( $format, $raw_kilo );
    my $mega = sprintf( $format, $raw_mega );
    my $giga = sprintf( $format, $raw_giga );
    my $one = sprintf( $format, $num );

    print "$giga, $mega, $kilo, $one\n" if( $debug );

    if( $raw_giga >= 1 ) {
        if( length( $giga ) < $max_len ) {
            return $giga . 'G';
        } else {
            $sig > 0 ?
                return &format_memory( $num, $sig - 1, $max_len, $debug ) :
                return $giga . 'G';
        }
    } elsif( $raw_mega >= 1 ) {
        if( length( $mega ) < $max_len ) {
            return $mega . 'M';
        } else {
            $sig > 0 ?
                return &format_memory( $num, $sig - 1, $max_len, $debug ) :
                return $mega . 'M';
        }
    } elsif( $raw_kilo >= 1 ) {
        if( length( $kilo ) < $max_len ) {
            return $kilo . 'K';
        } else {
            $sig > 0 ?
                return &format_memory( $num, $sig - 1, $max_len, $debug ) :
                return $kilo . 'K';
        }
    } else {
        if( length( $one ) <= $max_len ) {
            return $one;
        } else {
            $sig > 0 ?
                return &format_memory( $num, $sig - 1, $max_len, $debug ) :
                return $one;
        }
    }
}

sub show_simple_avg {
    my($sum,$index,$stats,$nsamples,$width,$sig,$stat,@which) = @_;
    my $entry = $$sum[$index];
    my $j = 0;

    foreach my $metric( @which ) {
        my $val;
        if( $entry && $nsamples ) {
            $val = $$entry[$metric] / $nsamples;

            my $pretty = &format_number( $val, $sig, $width-1 );
            $outbuf .= sprintf(" %*s", $width-1, $pretty );
        } else {
	        $outbuf .= sprintf(" %*s",$width-1,"-");
        }
	    add_stats($j+$stat,$stats,$val,$width);
        $j++;
    }
}

sub show_simple_avg_2 {
    my($sum,$index,$stats,$nsamples,$width,$sig,$stat,@which) = @_;
    my $entry = $$sum[$index];
    my $j = 0;

    foreach my $metric( @which ) {
        my $val;
        if( $entry && $nsamples ) {
            $val = $$entry[$metric] / $nsamples;
	    
            my $pretty = &format_number_2( $val, $sig, $width-1 );
            $outbuf .= sprintf(" %*s", $width-1, $pretty );
        } else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
        }
	add_stats($j+$stat,$stats,$val,$width);
        $j++;
    }
}

sub show_bytes_avg {
    my($sum,$index,$stats,$nsamples,$width,$sig,$stat,@which) = @_;
    my $entry = $$sum[$index];
    my $j = 0;

    foreach my $metric( @which ) {
        my $val;
        if( $entry && $nsamples ) {
            $val = $$entry[$metric] / $nsamples;
            my $pretty = &format_memory( $val, $sig, $width-1 );
            $outbuf .= sprintf(" %*s", $width-1, $pretty );
        } else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
        }
	add_stats($j+$stat,$stats,$val,$width);
        $j++;
    }
}


sub show_avg {
    my($width,$index,$nsamples,$scale,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    for my $i (@which) {
	my $pv;
	if ($l && $i < @$l && $nsamples) {
	    my $s = ref($scale) ? $$scale[$j] : $scale;
	    if (defined($s) && $s != 0) {
		$pv = $$l[$i]/$nsamples/$s;
		$outbuf .= sprintf(" %*.1f",$width-1,$pv);
		$outstats++;
	    } else {
		$outbuf .= sprintf(" %*s",$width-1,"-");
	    }
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}


sub show_avg_w {
    my($index,$nsamples,$scale,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
	my $i = shift(@which);
	my $width = shift(@which);
	my $pv;
	if ($l && $nsamples && defined($$l[$i])) {
	    my $s = ref($scale) ? $$scale[$j] : $scale;
	    my $fmt;
	    if (defined($s) && $s != 0) {
		if ($s < 0) {
		    $fmt =  " %*.2f";
		    $s = -$s;
		} else {
		    $fmt = " %*.1f";
		}
		$pv = $$l[$i]/$nsamples/$s;
		$outbuf .= sprintf($fmt,$width-1,$pv);
		$outstats++;
	    } else {
		$outbuf .= sprintf(" %*s",$width-1,"-");
	    }
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}


sub show_ratio {
    my($width,$index,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
	my $n = shift(@which);
	my $d = shift(@which);
	my $pv;
	if ($l && $n < @$l && $d < @$l) {
	    $pv = $$l[$d] ? $$l[$n]/$$l[$d]*100 : 0;
	    $outbuf .= sprintf(" %*.2f",$width-1,$pv);
	    $outstats++;
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}


sub show_ratio_1 {
    my($width,$index,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
	my $n = shift(@which);
	my $d = shift(@which);
	my $pv;
	if ($l && $n < @$l && $d < @$l) {
	    $pv = ($$l[$d]+$$l[$n]) ? $$l[$n]/($$l[$d]+$$l[$n])*100 : 0;
	    $outbuf .= sprintf(" %*.2f",$width-1,$pv);
	    $outstats++;
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}


sub show_ratio_2 {
    my($width,$index,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
	my $n = shift(@which);
	my $d = shift(@which);
	my $pv;
	if ($l && $n < @$l && $d < @$l) {
	    $pv = ($$l[$n]) ? ($$l[$n]-$$l[$d])/($$l[$n])*100 : 0;
	    $outbuf .= sprintf(" %*.2f",$width-1,$pv);
	    $outstats++;
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}


sub show_ratio_3 {
    my($width,$index,$scale,$val,$stats,$stat,@which) = @_;
    my $l = defined($index) ? $$val[$index] : 0;
    my $j = 0;
    while (@which) {
	my $n = shift(@which);
	my $d = shift(@which);
	my $s = ref($scale) ? $$scale[$j] : $scale;
	my $pv;
	if ($l && $n < @$l && $d < @$l && $$l[$d] > 0) {
	    $pv = ($$l[$n]) ? ($$l[$n])/($$l[$d])*$s : 0;
	    $outbuf .= sprintf(" %*.2f",$width-1,$pv);
	    $outstats++;
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}

sub show_ratio_4 {
    my($width,$index,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
	my $n = shift(@which);
	my $d = shift(@which);
	my $pv;
	if ($l && $n < @$l && $d < @$l) {
	    $pv = $$l[$d] ? $$l[$n]/$$l[$d]*100 : 0;
	    $outbuf .= sprintf(" %*i",$width-1,$pv);
	    $outstats++;
	} else {
	    $outbuf .= sprintf(" %*s",$width-1,"-");
	}
	add_stats($j+$stat,$stats,$pv,$width);
	$j++;
    }
}

sub add_stats {
    my($i,$stats,$pv,$width) = @_;
    my $s = $$stats[$i];
    if ($s) {
	if (defined($pv)) {
	    $$s[$STAT_SUM] += $pv;

	    # if this is the first value then we'll set
	    # to be the min/max values by default
	    
	    if ($$s[$STAT_SAMPLES] == 0) {
		$$s[$STAT_MIN] = $pv;
		$$s[$STAT_MAX] = $pv;
	    } else {
		if ($pv < $$s[$STAT_MIN]) {
		    $$s[$STAT_MIN] = $pv;
		}
		if ($pv > $$s[$STAT_MAX]) {
		    $$s[$STAT_MAX] = $pv;
		}
	    }
	    $$s[$STAT_SAMPLES]++;
	}
    } else {
	my $samp;
	if (defined($pv)) {
	    $samp = 1;
	} else {
	    $pv = 0;
	    $samp = 0;
	}
	$$stats[$i] = [$pv,$samp,$pv,$pv,$width];
    } 
}


sub add_sum_stats {
    my($t,$vals,$stats) = @_;

    for (my $i = 0; $i < @$vals; $i++) {
	my $s = $$stats[$i];
	next if !defined($$vals[$i]);
	if ($$vals[$i] == $$s[$STAT_MIN]) {
	    $$s[$STAT_MINTIME] = $t;
	}
	if ($$vals[$i] == $$s[$STAT_MAX]) {
	    $$s[$STAT_MAXTIME] = $t;
	    for (my $j = 0; $j < @$vals; $j++) {
		my $s = $$stats[$j];
		$$s[$i + $STAT_MAXBASE] = $$vals[$j];
	    }
	}
    }
}

sub show_mysql_stats {
    my($i,$stats) = @_;
    for (my $j = 0; $j <= $#$stats; $j++) {
	    my $s = $$stats[$j];
	    my $sv;
        if ($i == $STAT_SAMPLES) {
            $sv = $$s[$STAT_SAMPLES]
            ? $$s[$STAT_SUM] / $$s[$STAT_SAMPLES]
            : 0;
        } else {
            $sv = $$s[$i];
        }
        if( $j == 2 or $j == 3 ) {
            $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_memory( $sv, 1, 4 ));
        } else {
            $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_number( $sv, 1, 4 ));
        }
    }
}

sub show_ysquid_stats {
    my($i,$stats) = @_;
    for (my $j = 0; $j <= $#$stats; $j++) {
	    my $s = $$stats[$j];
	    my $sv;
        if ($i == $STAT_SAMPLES) {
            $sv = $$s[$STAT_SAMPLES]
            ? $$s[$STAT_SUM] / $$s[$STAT_SAMPLES]
            : 0;
        } else {
            $sv = $$s[$i];
        }
        $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_number( $sv, 0, 4 ));
    }
}

# FIXME: is this right?
sub show_ysquidhealth_stats {
    my($i,$stats) = @_;
    for (my $j = 0; $j <= $#$stats; $j++) {
        my $s = $$stats[$j];
        my $sv;
        if ($i == $STAT_SAMPLES) {
            $sv = $$s[$STAT_SAMPLES]
            ? $$s[$STAT_SUM] / $$s[$STAT_SAMPLES]
            : 0;
        } else {
            $sv = $$s[$i];
        }
        $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_number( $sv, 0, 4 ));
    }	
}

sub show_plugin_stats {
    my($i,$stats) = @_;
    for (my $j = 0; $j <= $#$stats; $j++) { 
            my $s = $$stats[$j];
            my $sv; 
        if ($i == $STAT_SAMPLES) {
            $sv = $$s[$STAT_SAMPLES]
            ? $$s[$STAT_SUM] / $$s[$STAT_SAMPLES]
            : 0;    
        } else {
            $sv = $$s[$i];
        }       
        $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_number( $sv, 0, 4 ));
    }
}

sub show_innodb_stats {
    my($i,$stats) = @_;
    for (my $j = 0; $j <= $#$stats; $j++) {
	    my $s = $$stats[$j];
	    my $sv;
        if ($i == $STAT_SAMPLES) {
            $sv = $$s[$STAT_SAMPLES]
            ? $$s[$STAT_SUM] / $$s[$STAT_SAMPLES]
            : 0;
        } else {
            $sv = $$s[$i];
        }
        if( $j == 12 or $j == 14 ) {
            $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_memory( $sv, 1, 4 ));
        } else {
            $outbuf .= sprintf( "%*s", $$s[$STAT_WIDTH], &format_number( $sv, 1, 4 ));
        }
    }
}

sub show_stats {
    my($i,$stats,$from,$to) = @_;
    if (!defined($from)) {
	$from = 0;
    }
    if (!defined($to)) {
	$to = @$stats-1;
    }
    for (my $j = $from; $j <= $to; $j++) {
	my $s = $$stats[$j];
	my $sv;
	if ($i == $STAT_SAMPLES) {
	    $sv = $$s[$STAT_SAMPLES]
		? $$s[$STAT_SUM] / $$s[$STAT_SAMPLES]
		: 0;
	} else {
	    $sv = $$s[$i];
	}
	$outbuf .= sprintf(" %*.1f",$$s[$STAT_WIDTH]-1,$sv);
    }
}

sub plugin_conf {

   unless (scalar(@pc)) { return 0; }

   my ($t,$ret,$i) = (shift,undef,1);

   foreach my $p (@plugins) {

      my $n = $$p{'NAME'};
      my $ucn = uc($$p{'NAME'});
      my @m = split(/,/,uc($$p{'METRICS'}));
      my ($oa,$ob);

      if ($t eq 'opts') {
         my $opt .= sprintf('$opt_%s',$n);
         $ret .= sprintf('use vars qw(%s); %s = %s;',$opt,$opt,0);
      }

      if ($t eq 'getopts') { $ret .=  sprintf('"%s" => \$opt_%s,',$n,$n); }

      if ($t eq 'metrics') {
         my ($ma,$mb,$mi) = (undef,undef,1);
         foreach my $m (@m) {
            $ma .= sprintf(' $%s_%s ',$ucn,$m);
            $mb .= ($mi eq (scalar(@m))) ? sprintf(' $%s_%s ',$ucn,$m) : sprintf(' $%s_%s, ',$ucn,$m);
            $mi++;
         }
         $ret .= sprintf('use vars qw(%s); (%s) = (0..%s);',$ma,$mb,(scalar(@m) - 1));
         $ret .= sprintf('use vars qw(@%s_sum @%s_prev @%s_ssum @%s_max);',$ucn,$ucn,$ucn,$ucn);
      }

      if ($t eq 'cgi') { $ret .= sprintf('$opt_%s = $cgi->param("%s"); ',$n,$n); }

      if ($t eq 'not_opt') { $ret .= (($i - 1) >= 1) ? sprintf(' && !$opt_%s',$n) : sprintf(' !$opt_%s',$n); }

      if ($t eq 'dat')  {
         $ret .= sprintf(' if ($opt_%s) { $dat = $dat{%s};',$n,$n);
         $ret .= sprintf(' if ($dat) { if ($ok) { max($index,$dat,\@%s_max); }',$ucn);
         $ret .= sprintf(' if ($ok) { add($index,$dat,\@%s_ssum); }',$ucn);
         $ret .= sprintf(' if (!defined($%s_prev[$%s_%s])) { @%s_prev = @$dat; } else {',$ucn,$ucn,$m[0],$ucn);
         $ret .= sprintf(' if (@%s_prev > 0) { delta($dat,\@%s_prev); } else { @%s_prev = @$dat; }',$ucn,$ucn,$ucn);
         $ret .= sprintf(' if ($ok) { add($index,$dat,\@%s_sum); } } } }',$ucn);
      } 

      if ($t eq 'stats') {
         if ($i eq 1) { $ret .= 'use vars qw('; } 
         $ret .= sprintf(' @%s_stats ',$ucn);
         if ($i eq scalar(@plugins)) { $ret .= ');'; }
      }
  
      if ($t eq 'show_stats') { $ret .= sprintf(' if ($opt_%s) { show_plugin_stats($i,\@%s_stats); }',$n,$ucn); }

      if ($t =~ /^header[12]$/) { $ret .= sprintf(' if ($opt_%s) { $outbuf .= "%s"; }',$n,$$p{uc($t)}); }

      if ($t eq 'usage') { $ret .= sprintf("    %s\n",$$p{'USAGE'}); } 

      if ($t eq 'columns') {
         $ret .= sprintf(' if ($opt_%s) {',$n);
         $ret .= sprintf(' my $stat = 0; my $pv; my $l = $%s_ssum[$i];',$ucn);
         $ret .= sprintf(' my $max = $%s_max[$i]; my $sum = $%s_sum[$i];',$ucn,$ucn);
         for (my $col = 0; $col < $$p{'NCOL'}; $col++) {
            my $cd = $$p{"COLUMN$col"};
            my ($type,$sm,$fp,$width) = split(/,/,$cd);
            my $ucsm = uc($sm);
            my @types = qw(val rate avg);
            if (grep $_ eq $type, @types) {
               my @mets = split(/\b/,$ucsm);
               $ret .= sprintf('$pv = ($l && defined($$l[$%s_%s])) ? ((',$ucn,$m[0]);
               foreach my $met (@mets) { $ret .= (grep $_ eq $met, @m) ? sprintf(' $$l[$%s_%s] ',$ucn,$met) : $met; }
               my $tavg = ($type eq 'rate') ? '/$tsamples[$i]' : ($type eq 'avg') ? '/$samples[$i]' : '';
               $ret .= sprintf(')%s) : undef; show_pluginval($pv,\@%s_stats,$stat++,%s,%s);',$tavg,$ucn,$width,$fp);
            }
            if ($type eq 'max') {
               $ret .= sprintf(' if ($max) { $pv = ($l && $$l[$%s_%s]) ? $$max[$%s_%s] : undef; }',$ucn,$ucsm,$ucn,$ucsm);
               $ret .= sprintf(' show_intval($pv,\@%s_stats,$stat++,%s);',$ucn,$width);
            }
         }
         $ret .= '}';
      } 

      $i++;

   }

   return $ret;

}

sub usage {
    print <<EOF
Usage: ysar [options] [groups]
Options:
    -accumulate         Accumulate data for past n days (preserving time-of-day)
    -day                Show single value for each day
    -current            Show average of current and previous sampling interval
    -header <lines>     Show header every <lines> lines (default: 40)
    -interval <mins>    Show values every <mins> minutes (default: 30)
    -ndays <days>       Show values for past <days> days (default: 1)
    -raw                Show values only (no headers or statistics)
    -log <filename>     Specify ysar log data file (default: /home/fih/logs/ysar/ysar.dat)
Groups:
    -Summary      (default) Summary of system activity
    -util         Utilization overview of cpu, memory, disk, and network.
    -cpu          CPU share (user, system, interrupt, nice, idle & iowait)
    -mem          Physical memory share (active, inactive, cached, free, wired)
    -memx         Memory extended counters on Linux (buffers, cached, swap and huge pages)
    -ps           Process state (# of procs in run, sleep, idle, disk-wait)
    -sys          System (context switches, syscalls, interrupts, traps per sec)
    -swap         Page-outs/ins (# swap, vnode pages out/in per sec)
    -fork         Forks (# forks, vforks per sec)
    -tcp          TCP (input pkts/bytes, output pkts/bytes, rexmit pkts/bytes)
    -udp          UDP (input pkts, output pkts, dropped input pkts)
    -ip           IP (input pkts, output pkts)
    -dev          Disk devices (read ops/bytes, write ops/bytes, %busy)
    -if           Network interfaces (input pkts/bytes, output pkts/bytes)
    -df           Disk space
    -load         Load
    -apache       apache (req/sec, avg response time, bytes in/out per request,
                  avg concurrent requests, max concurrent requests)
    -yts          YTS traffic performance (req/sec, mb/sec, connections)
    -ytscache     YTS cache metrics (cache hit ratio, read/write errors)
    -ytserr       YTS errors
    -ytstls       YTS TLS errors
    -ytsall       All YTS data (see above)
    -mysql        MySQL metrics
    -ysquid       Ysquid request metrics
    -ysquidhealth Ysquid health status
    -nfsrops      NFS read ops
    -nfswops      NFS write ops
    -nfscache     NFS cache performance (FreeBSD only)
    -nfsopx       NFS Operation specific performance. This option requires the
                  following -nfs-mount <mount> -nfs-op <op> where <op> is one of:
                  gattr, lkup, acces, rdlnk, read, rddir, rdir+, fssta, fsinf, pconf,
                  sattr, write, creat, mkdir, sylnk, mknod, remov, rmdir, renam, link
                  (Linux only)
    -ciss         HP RAID controller stats
    -kmem         Kernel memory stats
    -tcpx         Additional TCP stats
    -Max          Show stats for max req/sec, rt, cpu util, and memory util.
    -shmp         Shmproxy basic queue information
    -shmpd        Shmproxy drops
    -shmpci       Shmproxy clients in
    -shmpco       Shmproxy clients out
    -shmppi       Shmproxy proxy in
    -shmppo       Shmproxy proxy out
    -shmprd       Shmproxy raw drop counts
    -ynodejs      YNode JS (req/sec, latency, bytes in/out, avg and max concurrent requests)
EOF
;
    print plugin_conf('usage');
    exit(1);
}


sub plot {
    my $host = $opt_plot;
    open(OUT,">-");
    my $FETCH_BIN = "/usr/bin/wget";
    my $FETCH_OUT_OPT = "-O";
    my $PLOT_BIN_DIR = "/usr/bin";
    if ($^O eq "freebsd") {
	$PLOT_BIN_DIR = "/usr/local/bin";
	$FETCH_BIN = "/usr/bin/fetch";
	$FETCH_OUT_OPT = "-o";
    }
    if (!-x $FETCH_BIN
	|| !-x "$PLOT_BIN_DIR/gnuplot"
	|| !-x "$PLOT_BIN_DIR/pngtopnm"
	|| !-x "$PLOT_BIN_DIR/pnmcrop"
	|| !-x "$PLOT_BIN_DIR/pnmtopng")
    {
	bad_request("Plotting prerequisites missing");
    }
    if ($host =~ /^([A-Za-z0-9.-]+)$/) {
	$host = $1;
    } else {
	bad_request("Invalid host specified");
    }
    if ($plotcolors) {
	if ($plotcolors =~ /^([xA-Fa-f0-9]+)$/) {
	    $plotcolors = $1;
	} else {
	    bad_request("Invalid plotcolors parameter");
	}
    }
    if ($ndays) {
	if ($ndays =~ /^([0-9]+)$/) {
	    $ndays = $1;
	} else {
	    bad_request("Invalid ndays parameter");
	}
    }
    if ($interval) {
	if ($interval =~ /^([0-9]+)$/) {
	    $interval = $1;
	} else {
	    bad_request("Invalid interval parameter");
	}
    }
    if ($opt_plottype) {
	if ($opt_plottype =~ /^(util|apache|mysql)$/) {
	    $opt_plottype = $1;
	} else {
	    bad_request("Invalid plottype parameter");
	}
    }
    if (!$opt_plottype) {
	print OUT $cgi->header();
	print OUT $cgi->start_html("$host: System Activity");
	print OUT <<EOF
<table>
<tr>
<td valign="center"><form action="/ysar" method=GET>
Host <input name="plot" type="text" size="32" maxlength="64" value="$host">
<input type="submit" value="Plot"></td></tr></table>
<img src="/ysar?plot=$host&plottype=util&plotcolors=$plotcolors&ndays=$ndays">
<p>
<img src="/ysar?plot=$host&plottype=apache&plotcolors=$plotcolors&ndays=$ndays">
EOF
;
	print OUT $cgi->end_html();
	return;
    }

    my $plotdata = "/tmp/ysarplot.$$.dat";
    my $opt = '';
    if ($opt_plottype eq "mysql") {
	$opt = "&mysql=1";
    }
    system($FETCH_BIN,$FETCH_OUT_OPT,$plotdata,"http://$host/ysar?raw=1&header=0&ndays=$ndays&interval=$interval$opt");
    print OUT $cgi->header(-type => 'image/png');
    open(PLOT,"|$PLOT_BIN_DIR/gnuplot |$PLOT_BIN_DIR/pngtopnm |$PLOT_BIN_DIR/pnmcrop -top |$PLOT_BIN_DIR/pnmtopng");
    my $color = $plotcolors ? "color $plotcolors" : "";
    print PLOT <<EOF
set term png small $color
set xdata time
set timefmt "%m/%d-%H:%M"
set lmargin 10
set rmargin 10
set bmargin 3
set tmargin 1
set size ratio 0.5
EOF
;
    my(@TITLES) = ("",
		   "time",
		   "req/sec",
		   "avg response time (msec)",
		   "CPU %util",
		   "Memory %util",
		   "Swap pgs %",
		   "Syscalls/packet",
		   "Context switches/packet");
    my $DATAFILE = "'$plotdata' every ::1 using";
    if ($opt_plottype eq "util") {
	my @cols = (4,5);
	open(F,$plotdata);
	my $header = <F>;
	close(F);
	my(@fields) = split(/\s+/,$header);
	my %nics;
	for (my $i = 8; $i < @fields; $i++) {
	    if ($fields[$i] =~ /^(.+\d)(in|out)$/) {
		my $t = $1." ".$2."put";
		push(@TITLES,$t);
		$nics{$i+1} = 1;
	    } elsif ($fields[$i] =~ /^\//) {
		push(@TITLES,$fields[$i]." %full");
	    } else {
		push(@TITLES,$fields[$i]." %busy");
	    }
	    push(@cols,$i+1);
	}

	my $cmd = '';
	for my $col (@cols) {
	    if ($cmd) {
		$cmd .= ",";
	    }
	    my $x = '';
	    if ($nics{$col}) {
		$x = "axes x1y2";
	    }
	    $cmd .= " $DATAFILE 1:$col $x title '".$TITLES[$col]."'"
		." with lines lw 2";
	}
	print PLOT <<EOF
set ylabel "%"
set y2label "kb/sec"
set y2tics
set ytics nomirror
EOF
;
	print PLOT "set yrange [0:100]; plot ".$cmd;
    } elsif ($opt_plottype eq "apache") {
	my $cmd = '';
	$cmd .= " $DATAFILE 1:2 title '".$TITLES[2]."'"
	    ." with lines lw 2";
	$cmd .= ", $DATAFILE 1:3 axes x1y2 title '".$TITLES[3]."'"
	    ." with lines lw 2";
	print PLOT <<EOF
set ylabel "requests/sec"
set y2label "msec"
set y2tics
set ytics nomirror
EOF
;
	print PLOT "plot ".$cmd;
    } elsif ($opt_plottype eq "mysql") {
	my $cmd = "$DATAFILE 1:3 title 'numq' with lines lw 3"
	    .", $DATAFILE 1:6 title 'nsel' with lines lw 3"
	    .", $DATAFILE 1:7 title 'nins' with lines lw 3"
	    .", $DATAFILE 1:8 title 'nupd' with lines lw 3"
	    .", $DATAFILE 1:9 title 'ndel' with lines lw 3"
	    .", $DATAFILE 1:13 axes x1y2 title '%kbuf miss' with lines lw 3"
	    .", $DATAFILE 1:14 axes x1y2 title '%lock wait' with lines lw 3"
	    .", $DATAFILE 1:15 axes x1y2 title '%qcache miss' with lines lw 3"
	    .", $DATAFILE 1:((\$10>\$3)?100:(\$10/\$3*100)) axes x1y2 title '%slow' with lines lw 3";
	print PLOT <<EOF
set ylabel "queries/sec"
set y2label "%"
set y2tics
set ytics nomirror
EOF
;
	print PLOT "plot ".$cmd;
    }
    close PLOT;
    unlink($plotdata);
}


sub bad_request {
    my($what) = @_;
    print OUT $cgi->header("text/html","400 Bad Request");
    print OUT $cgi->start_html("ysar: $what");
    print OUT "<h1>ysar error: $what</h1>";
    print OUT $cgi->end_html();
    exit 0;
}


sub clamp {
    my($data,$lowside,$highside) = @_;

    for (my $i = 0; $i < @$data; $i++) {
      my $v;
      $v = $$data[$i];
      if (defined $v ){
              if(defined $lowside and $v < $lowside){
                      $$data[$i] = $lowside;
              }elsif (defined $highside and $highside < $v) {
                      $v = $highside;
                      $$data[$i] = $highside;
              }
      }
    }

}




sub show_avg_w_r{
    my($index,$nsamples,$scale,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
      my $i = shift(@which);
      my $width = shift(@which);
      my $resolution = shift(@which);
      my $pv;
      if ($l && $nsamples && defined($$l[$i])) {
          my $s = ref($scale) ? $$scale[$j] : $scale;
          my $fmt;
          if ($s < 0) {
              $resolution += 1;
              $fmt =  " %*.${resolution}f";
              $s = -$s;
          } else {
              $fmt = " %*.${resolution}f";
          }
          $pv = $$l[$i]/$nsamples/$s;
          $outbuf .= sprintf($fmt,$width-1,$pv);
          $outstats++;
      } else {
          $outbuf .= sprintf(" %*s",$width-1,"-");
      }
      add_stats($j+$stat,$stats,$pv,$width);
      $j++;
    }
}


sub show_ratio_r{
    my($width,$index,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
      my $n = shift(@which);
      my $d = shift(@which);
      my $r = shift(@which);
      my $pv;
      if ($l && $n < @$l && $d < @$l) {
          $pv = $$l[$d] ? $$l[$n]/$$l[$d]*100 : 0;
          $outbuf .= sprintf(" %*.${r}f",$width-1,$pv);
          $outstats++;
      } else {
          $outbuf .= sprintf(" %*s",$width-1,"-");
      }
      add_stats($j+$stat,$stats,$pv,$width);
      $j++;
    }
}


sub show_ratio_r_noperc{
    my($width,$index,$val,$stats,$stat,@which) = @_;
    my $l = $$val[$index];
    my $j = 0;
    while (@which) {
      my $n = shift(@which);
      my $d = shift(@which);
      my $r = shift(@which);
      my $pv;
      if ($l && $n < @$l && $d < @$l) {
          $pv = $$l[$d] ? $$l[$n]/$$l[$d] : 0;
          $outbuf .= sprintf(" %*.${r}f",$width-1,$pv);
          $outstats++;
      } else {
          $outbuf .= sprintf(" %*s",$width-1,"-");
      }
      add_stats($j+$stat,$stats,$pv,$width);
      $j++;
    }
}

sub only_ysquid_requested {
    if  ($opt_cpushare || $opt_load || $opt_mem || $opt_ps || $opt_sys || $opt_swap
	 || $opt_fork || $opt_tcp || $opt_udp || $opt_ip || $opt_devstat
	 || $opt_if || $opt_df || $opt_apache || $opt_yts || $opt_ytsall
	 || $opt_innodb || $opt_ysquidhealth || $opt_memx || $opt_nfsopx
	 || $opt_ytserr || $opt_ytscache || $opt_mysql || $opt_nfsrops
	 || $opt_nfswops || $opt_nfscache || $opt_util || $opt_ciss
	 || $opt_tcpx || $opt_kmem || $opt_shmproxy_que || $opt_shmproxy_drops 
	 || $opt_shmproxy_ci || $opt_shmproxy_co || $opt_shmproxy_pi
	 || $opt_shmproxy_po || $opt_shmproxy_rd || $opt_ynodejs) {
	return 0;
    } else {
	return 1;
    }
}

sub valid_nfs_op {    
    my @valid_nfsops = ("read", "gattr", "lkup", "acces", "rdlnk", 
	"rddir", "rdir+", "fssta", "fsinf", "pconf", "write",
	"sattr", "creat", "mkdir", "sylnk", "mknod", "remov",
	"rmdir", "renam", "link");

    if (grep {$_ eq $opt_nfsop_op} @valid_nfsops) {
	return 1;
    } else {
	return 0;
    }
}

sub nfs_op_status_counters {

    my %hash_counters = (
	"read" => [$NFS_LX_READ_OPS,$NFS_LX_READ_KB,$NFS_LX_READ_RETRANS,$NFS_LX_READ_RTT,$NFS_LX_READ_EXE],
	"gattr" => [$NFS_LX_GATTR_OPS,$NFS_LX_GATTR_KB,$NFS_LX_GATTR_RETRANS,$NFS_LX_GATTR_RTT,$NFS_LX_GATTR_EXE],
	"lkup" => [$NFS_LX_LOOKUP_OPS,$NFS_LX_LOOKUP_KB,$NFS_LX_LOOKUP_RETRANS,$NFS_LX_LOOKUP_RTT,$NFS_LX_LOOKUP_EXE],
	"acces" => [$NFS_LX_ACCESS_OPS,$NFS_LX_ACCESS_KB,$NFS_LX_ACCESS_RETRANS,$NFS_LX_ACCESS_RTT,$NFS_LX_ACCESS_EXE],
	"rdlnk" => [$NFS_LX_RDLINK_OPS,$NFS_LX_RDLINK_KB,$NFS_LX_RDLINK_RETRANS,$NFS_LX_RDLINK_RTT,$NFS_LX_RDLINK_EXE],
	"rddir" => [$NFS_LX_RDDIR_OPS,$NFS_LX_RDDIR_KB,$NFS_LX_RDDIR_RETRANS,$NFS_LX_RDDIR_RTT,$NFS_LX_RDDIR_EXE],
	"rdir+" => [$NFS_LX_RDDIRPLUS_OPS,$NFS_LX_RDDIRPLUS_KB,$NFS_LX_RDDIRPLUS_RETRANS,$NFS_LX_RDDIRPLUS_RTT,$NFS_LX_RDDIRPLUS_EXE],
	"fssta" => [$NFS_LX_FSSTAT_OPS,$NFS_LX_FSSTAT_KB,$NFS_LX_FSSTAT_RETRANS,$NFS_LX_FSSTAT_RTT,$NFS_LX_FSSTAT_EXE],
	"fsinf" => [$NFS_LX_FSINFO_OPS,$NFS_LX_FSINFO_KB,$NFS_LX_FSINFO_RETRANS,$NFS_LX_FSINFO_RTT,$NFS_LX_FSINFO_EXE],
	"pconf" => [$NFS_LX_PCONF_OPS,$NFS_LX_PCONF_KB,$NFS_LX_PCONF_RETRANS,$NFS_LX_PCONF_RTT,$NFS_LX_PCONF_EXE],
	"write" => [$NFS_LX_WRITE_OPS,$NFS_LX_WRITE_KB,$NFS_LX_WRITE_RETRANS,$NFS_LX_WRITE_RTT,$NFS_LX_WRITE_EXE],
	"sattr" => [$NFS_LX_SATTR_OPS,$NFS_LX_SATTR_KB,$NFS_LX_SATTR_RETRANS,$NFS_LX_SATTR_RTT,$NFS_LX_SATTR_EXE],
	"creat" => [$NFS_LX_CREATE_OPS,$NFS_LX_CREATE_KB,$NFS_LX_CREATE_RETRANS,$NFS_LX_CREATE_RTT,$NFS_LX_CREATE_EXE],
	"mkdir" => [$NFS_LX_MKDIR_OPS,$NFS_LX_MKDIR_KB,$NFS_LX_MKDIR_RETRANS,$NFS_LX_MKDIR_RTT,$NFS_LX_MKDIR_EXE],
	"sylnk" => [$NFS_LX_SYMLINK_OPS,$NFS_LX_SYMLINK_KB,$NFS_LX_SYMLINK_RETRANS,$NFS_LX_SYMLINK_RTT,$NFS_LX_SYMLINK_EXE],
	"mknod" => [$NFS_LX_MKNODE_OPS,$NFS_LX_MKNODE_KB,$NFS_LX_MKNODE_RETRANS,$NFS_LX_MKNODE_RTT,$NFS_LX_MKNODE_EXE],
	"remov" => [$NFS_LX_REMOVE_OPS,$NFS_LX_REMOVE_KB,$NFS_LX_REMOVE_RETRANS,$NFS_LX_REMOVE_RTT,$NFS_LX_REMOVE_EXE],
	"rmdir" => [$NFS_LX_RMDIR_OPS,$NFS_LX_RMDIR_KB,$NFS_LX_RMDIR_RETRANS,$NFS_LX_RMDIR_RTT,$NFS_LX_RMDIR_EXE],
	"renam" => [$NFS_LX_RENAME_OPS,$NFS_LX_RENAME_KB,$NFS_LX_RENAME_RETRANS,$NFS_LX_RENAME_RTT,$NFS_LX_RENAME_EXE],
	"link" => [$NFS_LX_LINK_OPS,$NFS_LX_LINK_KB,$NFS_LX_LINK_RETRANS,$NFS_LX_LINK_RTT,$NFS_LX_LINK_EXE]
	);

    my $counters = $hash_counters{$opt_nfsop_op};
    return($$counters[0],$$counters[1],$$counters[2],$$counters[3],$$counters[4]);
}
